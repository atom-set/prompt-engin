---
name: document-format
description: 文档格式规范，包括任务清单、测试用例、文章报告等格式要求
priority: 4
tags: ['document', 'format', 'structure']
---

# 文档格式规范

## 使用场景

当用户需要：
- 创建任务清单时
- 生成测试用例时
- 编写分析报告时
- 生成任何文档时

## 触发条件

以下情况自动应用此规范：
- 用户要求创建文档时
- AI 助手生成文档输出时
- 用户明确要求应用此规范时

## 与其他规则的配合

- **依赖关系**：
  - `time-format`：创建包含时间字段的文档时，必须遵循时间格式规范，使用实际时间，禁止使用假设日期
- 与核心规则配合使用

---

### 强制要求
- **核心原则**：文档输出必须结构清晰、格式统一、便于阅读和维护
- **适用范围**：所有文档输出，包括任务清单、测试用例、文章报告等

### 通用输出规范

#### 文档内容原则

- **按需输出**：只输出用户明确要求的内容，不添加额外的非必要部分
- **禁止默认添加QA**：除非用户明确要求，否则不要在文档末尾添加"常见问题"、"FAQ"、"QA"等部分
- **保持简洁**：避免添加用户未要求的补充说明、注意事项等内容（除非对理解核心内容至关重要）
- **代码输出限制**：非开发环境，没有明确的指令不要输出代码；只有在用户明确要求输出代码时，才提供代码示例

#### 禁止默认添加QA的检查机制

**核心原则**：在生成文档前，必须检查文档内容是否包含禁止的QA相关内容。

- **检查时机**：在调用 `write` 工具写入文档内容前，必须检查
- **检查内容**：检查文档内容是否包含以下关键词：
  - "常见问题"
  - "FAQ"
  - "QA"
  - "Q&A"
  - "问题解答"
  - "常见问题解答"
- **检查流程**：
  1. 在写入文档前，检查文档内容是否包含上述关键词
  2. 如果包含且用户未明确要求，必须删除相关内容
  3. 如果用户明确要求添加QA，可以保留
- **禁止的行为**：
  - ❌ 在用户未明确要求的情况下，添加"常见问题"、"FAQ"等部分
  - ❌ 跳过检查直接写入包含QA内容的文档
  - ❌ 假设用户需要QA部分
- **正确做法**：
  - ✅ 在写入前检查文档内容
  - ✅ 如果发现QA相关内容且用户未要求，删除后再写入
  - ✅ 如果用户明确要求添加QA，可以保留

**检查示例**：

```typescript
// 伪代码示例
function checkQAContent(content: string, userRequest: string): boolean {
  const qaKeywords = ['常见问题', 'FAQ', 'QA', 'Q&A', '问题解答', '常见问题解答'];
  const hasQA = qaKeywords.some(keyword => content.includes(keyword));
  const userRequestedQA = userRequest.includes('常见问题') || 
                         userRequest.includes('FAQ') || 
                         userRequest.includes('QA');
  
  // 如果包含QA内容但用户未要求，返回false（需要删除）
  if (hasQA && !userRequestedQA) {
    return false;  // 需要删除QA内容
  }
  
  return true;  // 可以写入
}
```

### 任务清单格式要求

#### 表格格式要求（强制）

任务清单必须始终使用表格形式展示：

- **必须使用表格形式**：任务清单必须始终使用表格展示，禁止使用列表形式
- **禁止列表格式**：不要使用 `- [ ] 任务1` 这样的列表格式
- **表格结构清晰**：表格应包含明确的列标题，便于阅读和维护

**任务概览表格示例**：

| 模块编号 | 模块名称 | 任务数量 | 状态 | 优先级 | 预计耗时 | 备注 |
|---------|---------|---------|------|--------|---------|------|
| M01 | 配置环境 | 3 | 进行中 | P0 | 0.5PD | 依赖服务器资源 |
| M02 | 接口开发 | 5 | 待开始 | P0 | 0.5PD | - |

**详细任务表格示例**：

| 任务名称 | 状态 | 优先级 | 预计耗时 | 负责人 | 备注 |
|---------|------|--------|---------|--------|------|
| 配置开发环境 | 待开始 | P0 | 0.5PD | 张三 | 依赖服务器配置 |
| 接口开发 | 进行中 | P0 | 0.5PD | 李四 | 预计2天完成 |

#### 结构要求（金字塔原理：总分总）

任务清单必须遵循**金字塔原理的总分总结构**：

1. **总（概览）**：首先提供任务概览表格
   - 展示高层次的任务模块，用于确认任务完整性
   - 概览表格应包含：模块编号、模块名称、任务数量、状态、优先级、预计耗时、备注等列
   - 目的是先确认整体任务范围是否完整，避免遗漏重要模块

2. **分（详细）**：在概览确认完整后，再展开详细的任务清单表格
   - 每个模块下展开具体任务项
   - 详细表格应包含：任务名称/描述、状态、优先级、预计耗时、负责人/备注等列
   - 提供任务的具体实施细节

3. **总（总结）**：最后提供总结和注意事项
   - 总结任务清单的关键点
   - 列出重要的注意事项和依赖关系

#### 工作流程

1. **先确认概览**：与用户确认任务概览是否完整，是否遗漏重要模块
2. **再详细拆解**：在概览确认完整后，再进行详细任务拆解
3. **避免遗漏**：通过概览先行，确保整体任务范围完整

#### 重要原则

- 任务清单**只包含开发任务**，如：配置、接口开发、前端开发、文档编写、上线准备等
- **不包含任何测试用例**，测试用例应单独管理
- **不涉及具体的代码片段**：任务描述应使用自然语言，避免包含代码示例或具体的代码片段

### 测试用例格式要求

- **必须使用表格形式展示**，包含以下列：
  - 用例编号/ID
  - 测试场景/用例名称
  - 测试步骤
  - 预期结果
  - 实际结果（执行时填写）
  - 状态（通过/失败/待执行）
- **重要原则**：
  - 测试用例**必须单独管理**，不放在任务清单中
  - 建议使用独立的测试用例文档或测试用例管理工具
  - 测试用例文档可以按测试类型分类（功能测试、兼容性测试、性能测试等）

### 文章报告格式要求

#### 结构要求（总分总格式）

**文章报告必须遵循总分总结构**，确保内容逻辑清晰、层次分明：

1. **总（开头）**：概述部分
   - 提供文章的背景、目的和核心观点
   - 简要说明文章要解决的问题或要传达的信息
   - 可以包括：背景介绍、问题陈述、目标说明、核心结论预览
   - **目的**：让读者快速了解文章主旨，建立阅读预期

2. **分（主体）**：详细内容部分
   - 展开详细的分析、论述、数据、案例等
   - 按照逻辑顺序组织内容，可以使用多个小节
   - 每个小节应有明确的主题，内容详实、有据可依
   - 可以包括：详细分析、数据展示、场景说明、计算过程、对比分析等
   - **目的**：提供充分的信息支撑，让读者深入理解主题

3. **总（结尾）**：总结部分
   - 总结文章的核心观点和关键发现
   - 提炼主要结论和建议
   - 可以包括：核心结论、关键数据汇总、优化建议、下一步行动等
   - **目的**：强化核心信息，帮助读者形成清晰的认识

#### 适用文档类型

以下类型的文档应遵循总分总格式：

- ✅ **分析报告**：数据分析报告、性能分析报告、问题分析报告等
- ✅ **评估文档**：费用评估、技术方案评估、风险评估等
- ✅ **说明文档**：功能说明、使用说明、计算逻辑说明等
- ✅ **总结文档**：项目总结、工作总结、经验总结等
- ✅ **方案文档**：技术方案、优化方案、解决方案等
- ✅ **其他报告类文档**：任何需要清晰传达信息的报告类文档

#### 重要原则

- **逻辑清晰**：确保"总-分-总"三个部分逻辑连贯，相互呼应
- **重点突出**：开头和结尾应突出核心观点，主体部分提供充分支撑
- **层次分明**：使用合适的标题层级，让结构一目了然
- **数据支撑**：主体部分应包含充分的数据、案例、分析等支撑材料
- **易于理解**：避免过于复杂的长句，使用表格、列表等提高可读性

### 生成文档文件命名规范

#### 命名原则

- **核心原则**：创建生成的 Markdown 文件应包含时间标识或版本标识，便于区分和管理
- **适用范围**：所有自动生成或定期生成的文档，包括报告、分析文档、测试报告等
- **标识选择**：根据文档类型选择合适的标识方式（时间标识或版本标识）

#### 命名格式

##### 时间标识格式

**格式定义**：`{文档名称}-{YYYY-MM-DD}.md`

- **文档名称**：使用 kebab-case（小写字母，单词间用连字符分隔）
- **日期格式**：YYYY-MM-DD（4位年-2位月-2位日）
- **获取方式**：必须使用 `date '+%Y-%m-%d'` 命令获取当前日期，禁止使用假设日期

**命名示例**：
- ✅ `rule-quality-report-2025-12-03.md` - 规则质量报告（带日期）
- ✅ `test-results-2025-12-03.md` - 测试结果报告（带日期）
- ✅ `performance-analysis-2025-12-03.md` - 性能分析报告（带日期）
- ❌ `rule-quality-report.md` - 缺少时间标识
- ❌ `rule-quality-report-2025-12-03.md`（使用假设日期）- 禁止使用假设日期

##### 版本标识格式

**格式定义**：`{文档名称}-v{版本号}.md`

- **文档名称**：使用 kebab-case（小写字母，单词间用连字符分隔）
- **版本号**：遵循语义化版本规范（Semantic Versioning）
  - 格式：`主版本号.次版本号.修订号`（如：v1.0.0、v2.1.3）
  - 主版本号：不兼容的 API 修改
  - 次版本号：向下兼容的功能性新增
  - 修订号：向下兼容的问题修正

**命名示例**：
- ✅ `api-specification-v1.0.0.md` - API 规范文档（带版本）
- ✅ `design-document-v2.1.3.md` - 设计文档（带版本）
- ✅ `user-manual-v1.2.0.md` - 用户手册（带版本）
- ❌ `api-specification.md` - 缺少版本标识

##### 时间+版本组合格式

**格式定义**：`{文档名称}-v{版本号}-{YYYY-MM-DD}.md`

- **适用场景**：需要同时标识版本和生成时间的文档
- **格式说明**：版本号在前，日期在后，用连字符分隔

**命名示例**：
- ✅ `rule-quality-report-v2.0-2025-12-03.md` - 规则质量报告（版本+日期）
- ✅ `test-results-v1.1-2025-12-03.md` - 测试结果报告（版本+日期）

#### 使用场景

##### 使用时间标识的场景

以下类型的文档应使用时间标识：

- ✅ **定期生成的报告**：每日/每周/每月生成的报告
  - 示例：`daily-report-2025-12-03.md`、`weekly-summary-2025-12-03.md`
- ✅ **测试报告**：测试执行后生成的报告
  - 示例：`test-results-2025-12-03.md`、`coverage-report-2025-12-03.md`
- ✅ **分析报告**：数据分析、性能分析等报告
  - 示例：`performance-analysis-2025-12-03.md`、`code-analysis-2025-12-03.md`
- ✅ **快照文档**：特定时间点的文档快照
  - 示例：`project-status-2025-12-03.md`、`backup-summary-2025-12-03.md`

##### 使用版本标识的场景

以下类型的文档应使用版本标识：

- ✅ **规范文档**：API 规范、设计规范等
  - 示例：`api-specification-v1.0.0.md`、`design-spec-v2.1.0.md`
- ✅ **手册文档**：用户手册、开发手册等
  - 示例：`user-manual-v1.2.0.md`、`developer-guide-v2.0.0.md`
- ✅ **配置文档**：配置文件说明、部署文档等
  - 示例：`deployment-guide-v1.0.0.md`、`config-reference-v2.1.3.md`

##### 使用时间+版本组合的场景

以下类型的文档应使用时间+版本组合：

- ✅ **版本化报告**：需要版本管理的报告文档
  - 示例：`rule-quality-report-v2.0-2025-12-03.md`
- ✅ **定期更新的规范**：定期更新但需要版本管理的规范文档
  - 示例：`coding-standards-v1.1-2025-12-03.md`

#### 获取时间的方法

**必须使用工具获取当前时间**，禁止使用假设日期：

```bash
# 获取 YYYY-MM-DD 格式的日期
date '+%Y-%m-%d'

# 获取完整日期时间
date '+%Y-%m-%d %H:%M:%S'
```

**重要原则**：
- ✅ **必须使用**：`date` 命令获取当前时间
- ❌ **禁止使用**：任何假设的日期（如 `2025-12-03`、`2025-01-01` 等）
- ❌ **禁止使用**：格式占位符（如 `YYYY-MM-DD`）
- ❌ **禁止使用**：模糊表述（如"今天"、"当前日期"）

#### 命名最佳实践

1. **文档名称清晰**：
   - ✅ 使用描述性的名称，清晰表达文档内容
   - ❌ 避免使用模糊的名称（如 `report.md`、`doc.md`）

2. **标识位置统一**：
   - 时间标识：放在文档名称后，用连字符分隔
   - 版本标识：放在文档名称后，用连字符分隔
   - 组合标识：版本在前，时间在后

3. **格式一致性**：
   - 同一类型的文档应使用相同的命名格式
   - 同一项目中的文档命名应保持一致

4. **避免冲突**：
   - 如果同一天生成多个相同类型的文档，可以在名称中添加序号或类型区分
   - 示例：`test-results-unit-2025-12-03.md`、`test-results-integration-2025-12-03.md`

#### 注意事项

1. **强制要求**：所有自动生成或定期生成的文档必须包含时间标识或版本标识
2. **时间获取**：时间标识必须使用 `date` 命令获取，禁止使用假设日期
3. **格式统一**：同一项目中的文档命名格式应保持一致
4. **版本管理**：使用版本标识的文档应遵循语义化版本规范
5. **文档管理**：定期清理过期的文档，避免积累过多历史文档