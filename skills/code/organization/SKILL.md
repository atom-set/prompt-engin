---
name: code-organization
description: 代码组织规范，包括文件大小限制、拆分原则等
priority: 4
tags: [code, organization, structure]
---

# 代码组织规范

## 使用场景

当用户需要：
- 创建新的代码文件时
- 向现有文件添加代码时
- 重构超过 500 行的代码文件时
- 进行代码审查，检查文件大小时

## 触发条件

以下情况自动应用此规范：
- 用户创建新文件或添加代码时
- AI 助手检测到文件行数接近或超过 500 行时
- 用户要求进行代码拆分或重构时

## 与其他规则的配合

- **依赖关系**：
  - `naming`：拆分文件时，文件命名应遵循命名规范，确保文件名清晰表达功能
  - `design-principles`：拆分文件时，应遵循简单设计原则，避免过度设计，保持文件职责单一
- 与核心规则配合使用

---

## 代码组织规范

### 强制要求
- **核心原则**：保持代码文件职责单一，控制文件大小，提高代码可维护性
- **适用范围**：所有代码文件（包括脚本、配置文件、业务代码等）

### 文件大小限制

#### 新增文件规范

- **代码行数限制**：新增文件的代码行数**不得超过 500 行**
- **单一职责原则**：每个文件应只负责一个明确的功能或职责
- **职能单一**：避免在一个文件中混合多个不相关的功能

#### 行数计算标准

- **包含内容**：
  - 代码行（包括注释）
  - 空行（用于代码可读性的空行）
  - 文档注释
- **不包含内容**：
  - 自动生成的代码（如某些框架生成的代码）
  - 大型数据结构的定义（如配置映射表、常量表等，如果超过 100 行，建议单独提取）

#### 判断标准

- **简单文件**（<200 行）：可以直接创建，无需拆分
- **中等文件**（200-500 行）：可以创建，但应确保职责单一
- **复杂文件**（>500 行）：**禁止创建**，必须拆分为多个文件

### 历史文件处理策略

#### 超过 500 行的历史文件

如果历史文件代码行数**超过 500 行**，新增代码应遵循以下策略：

#### 接近 500 行的历史文件

如果历史文件代码行数**不超过 500 行**，但新增代码后可能超过 500 行，新增代码也应遵循以下策略：

1. **新增代码放到新文件**：
   - 将新增功能代码放到新的独立文件中
   - 新文件应遵循单一职责原则
   - 新文件代码行数不得超过 500 行

2. **通过引入方式调用**：
   - 在历史文件中通过 `import`、`require`、`source` 等方式引入新文件
   - 保持原有文件的接口不变，确保向下兼容
   - 原有文件作为入口或协调层，调用新文件的功能

3. **保持接口稳定**：
   - 原有文件的公开接口（函数、类、方法等）应保持不变
   - 内部实现可以重构，但外部调用方式不应改变
   - 如需修改接口，应提供迁移方案

**判断标准**：
- **超过 500 行**：必须将新增代码放到新文件
- **接近 500 行**（如超过 400 行）：建议将新增代码放到新文件，避免文件过大
- **小于 400 行**：可以根据实际情况决定，但应保持文件职责单一

#### 拆分原则

1. **按功能拆分**：
   - 将不同功能模块拆分到独立文件
   - 每个文件负责一个明确的功能领域

2. **按层次拆分**：
   - 将不同层次的代码拆分（如：数据层、业务层、展示层）
   - 保持层次清晰，避免跨层次耦合

3. **按职责拆分**：
   - 将不同职责的代码拆分（如：工具函数、业务逻辑、配置管理）
   - 每个文件应有明确的职责边界

### 代码拆分方法

#### 拆分步骤

1. **识别拆分点**：
   - 分析文件中的功能模块
   - 识别可以独立的功能单元
   - 确定拆分后的文件结构

2. **创建新文件**：
   - 为新功能创建独立的文件
   - 文件命名应清晰表达其功能
   - 确保新文件代码行数不超过 500 行

3. **提取公共代码**：
   - 将公共函数、工具类等提取到独立文件
   - 通过引入方式在多个文件中复用

4. **更新原文件**：
   - 在原文件中引入新文件
   - 保持原文件的接口不变
   - 将具体实现委托给新文件

#### 拆分示例

**拆分前**（不推荐）：
```javascript
// main.js (600+ 行)
function processData() { /* ... */ }
function validateData() { /* ... */ }
function formatData() { /* ... */ }
function saveData() { /* ... */ }
// ... 更多函数
```

**拆分后**（推荐）：
```javascript
// main.js (入口文件，<200 行)
import { processData } from './data-processor.js';
import { validateData } from './data-validator.js';
import { formatData } from './data-formatter.js';
import { saveData } from './data-storage.js';

// 协调和调用各个模块
export function handleData(data) {
  const processed = processData(data);
  const validated = validateData(processed);
  const formatted = formatData(validated);
  return saveData(formatted);
}
```

```javascript
// data-processor.js (<200 行)
export function processData(data) { /* ... */ }
```

```javascript
// data-validator.js (<200 行)
export function validateData(data) { /* ... */ }
```

### 文件命名规范

#### 命名原则

- **清晰表达功能**：文件名应清晰表达文件的主要功能
- **遵循项目规范**：遵循项目已有的命名规范（如：kebab-case、camelCase、PascalCase）
- **避免过长**：文件名不应过长，建议不超过 30 个字符

#### 命名示例

- ✅ **好的命名**：
  - `data-processor.js`：数据处理
  - `user-validator.js`：用户验证
  - `config-manager.js`：配置管理
- ❌ **不好的命名**：
  - `utils.js`：过于宽泛
  - `helper.js`：不明确
  - `misc.js`：杂项，职责不清

### 代码组织最佳实践

#### 1. 优先拆分

- **新建功能时**：如果预计代码行数会超过 500 行，应提前规划文件结构，拆分为多个文件
- **重构时**：如果发现文件超过 500 行，应主动拆分，而不是继续增加代码

#### 2. 保持一致性

- **项目统一**：同一项目中的代码组织方式应保持一致
- **团队协作**：团队成员应遵循相同的代码组织规范

#### 3. 文档说明

- **文件头注释**：每个文件应在开头说明文件的主要功能和职责
- **拆分说明**：如果文件是拆分后的结果，应说明拆分的原因和关系

#### 4. 依赖管理

- **避免循环依赖**：拆分后的文件之间应避免循环依赖
- **依赖层次清晰**：保持依赖关系的层次清晰，避免深层嵌套

### 适用场景

**以下场景必须遵循此规范：**

- ✅ **新建文件**：创建新的代码文件时，必须确保代码行数不超过 500 行
- ✅ **功能扩展**：在现有文件中添加新功能时，如果文件已超过 500 行，应拆分到新文件
- ✅ **代码重构**：重构代码时，如果文件超过 500 行，应主动拆分
- ✅ **代码审查**：代码审查时，应检查文件大小是否符合规范

### 重要原则

1. **职责单一**：每个文件应只负责一个明确的功能或职责
2. **大小控制**：新增文件代码行数不得超过 500 行
3. **拆分优先**：历史文件超过 500 行时，新增代码应拆分到新文件
4. **接口稳定**：拆分时保持原有接口不变，确保向下兼容
5. **可维护性**：通过合理的代码组织，提高代码的可维护性和可读性

### 注意事项

1. **强制要求**：新增文件代码行数不得超过 500 行，这是强制要求，不是建议
2. **历史文件**：历史文件超过 500 行时，新增代码必须拆分到新文件
3. **向下兼容**：拆分历史文件时，必须保持原有接口不变
4. **团队协作**：团队成员应统一遵循此规范，保持代码组织的一致性
5. **持续重构**：定期检查文件大小，主动拆分超过 500 行的文件
