---
name: design-principles
description: 设计原则规范，强调简单设计优先，避免过度设计
tags: [rules, prompt-engine]
---

# 设计原则规范

## 使用场景

当用户需要：
- **应用此规范**时，自动加载此技能

## 触发条件

以下情况自动应用此规范：
- 用户要求应用相关规范时
- AI 助手识别到需要使用此规范时

## 与其他规则的配合

- 与其他规则技能配合使用
- 与核心规则配合使用

---

# 设计原则规范

> **文件说明**：本文件包含设计原则相关规则，强调简单设计优先，避免过度设计
> **规则来源**：rules/stages/common/code/design-principles/design-principles.md

---

## 设计原则规范

### 核心原则

- **简单设计优先**：优先考虑最简单的设计方案，只有在明确需要时才采用复杂方案
- **避免过度设计**：不要为了"未来可能的需求"而增加不必要的复杂度
- **场景驱动**：复杂方案必须基于明确的场景和需求，不能假设未来需求
- **渐进式演进**：从简单方案开始，根据实际需求逐步演进，而不是一开始就设计复杂方案

### 简单设计优先原则

#### 基本原则

1. **从最简单方案开始**：
   - 优先考虑最直接、最简单的实现方式
   - 使用语言和框架提供的原生功能，避免引入不必要的抽象层
   - 优先使用标准库和常见模式，避免自定义复杂机制

2. **避免过早抽象**：
   - 不要在没有明确需求时创建抽象层
   - 不要为了"复用"而创建不必要的抽象
   - 只有在实际出现重复代码（3次以上）时才考虑抽象

3. **最小化依赖**：
   - 优先使用项目已有的依赖和工具
   - 避免引入新的依赖，除非有明确且必要的理由
   - 评估新依赖的必要性和维护成本

#### 设计决策流程

**第一步：评估需求**

1. **明确当前需求**：
   - 当前需要解决什么问题？
   - 问题的核心是什么？
   - 是否有明确的边界和约束？

2. **识别简单方案**：
   - 最简单的实现方式是什么？
   - 能否用现有功能直接解决？
   - 是否需要引入新的概念或机制？

**第二步：选择方案**

1. **优先选择简单方案**：
   - 如果简单方案能满足当前需求，直接采用
   - 不要因为"未来可能需要"而选择复杂方案
   - 简单方案更容易理解、维护和测试

2. **复杂方案的条件**：
   - 只有在简单方案无法满足需求时，才考虑复杂方案
   - 复杂方案必须基于明确的场景和需求
   - 必须说明为什么简单方案不可行

**第三步：文档化决策**

1. **记录设计决策**：
   - 为什么选择这个方案？
   - 简单方案为什么不可行？
   - 复杂方案解决了什么问题？

2. **说明场景和约束**：
   - 在什么场景下需要复杂方案？
   - 有哪些约束条件？
   - 未来如何演进？

### 复杂方案的要求

#### 必须明确说明的内容

如果采用复杂方案，必须明确说明以下内容：

1. **场景说明**：
   - 在什么具体场景下需要复杂方案？
   - 简单方案为什么无法满足需求？
   - 有哪些明确的约束条件？

2. **需求分析**：
   - 当前需求是什么？
   - 未来可能的需求是什么（如果有）？
   - 这些需求是否已经明确，还是只是假设？

3. **方案对比**：
   - 简单方案是什么？
   - 简单方案的局限性是什么？
   - 复杂方案如何解决这些局限性？

4. **成本评估**：
   - 复杂方案的实现成本是多少？
   - 维护成本是多少？
   - 学习成本是多少？

#### 禁止的行为

- ❌ **禁止假设未来需求**：不能因为"未来可能需要"而采用复杂方案
- ❌ **禁止过度抽象**：不能在没有明确需求时创建抽象层
- ❌ **禁止过早优化**：不能为了"性能"或"扩展性"而增加不必要的复杂度
- ❌ **禁止复杂方案无场景说明**：复杂方案必须明确说明使用场景

### 设计示例

#### ✅ 好的做法：简单设计优先

**场景**：需要实现一个用户登录功能

**简单方案**：
```javascript
// 简单方案：直接实现登录功能
async function login(username, password) {
  const user = await db.findUser(username);
  if (!user || user.password !== hashPassword(password)) {
    throw new Error('用户名或密码错误');
  }
  return generateToken(user);
}
```

**说明**：
- 直接实现核心功能，没有不必要的抽象
- 使用标准库和常见模式
- 代码清晰易懂，易于维护

#### ⚠️ 复杂方案：需要明确场景

**场景**：需要支持多种登录方式（用户名、手机号、邮箱、第三方登录），且需要支持多种认证策略

**复杂方案**：
```javascript
// 复杂方案：使用策略模式和工厂模式
class LoginStrategy {
  async authenticate(credentials) { throw new Error('Not implemented'); }
}

class UsernameLoginStrategy extends LoginStrategy { /* ... */ }
class PhoneLoginStrategy extends LoginStrategy { /* ... */ }
class EmailLoginStrategy extends LoginStrategy { /* ... */ }
class ThirdPartyLoginStrategy extends LoginStrategy { /* ... */ }

class LoginFactory {
  createStrategy(type) { /* ... */ }
}

async function login(type, credentials) {
  const strategy = loginFactory.createStrategy(type);
  return strategy.authenticate(credentials);
}
```

**必须说明**：
- **场景**：需要支持多种登录方式，且未来可能继续扩展
- **简单方案局限性**：简单方案需要大量 if-else，难以扩展
- **复杂方案优势**：策略模式便于扩展新的登录方式
- **成本评估**：增加了代码复杂度，但提高了可扩展性

#### ❌ 不好的做法：过度设计

**场景**：只需要实现用户名密码登录

**过度设计**：
```javascript
// ❌ 不好的做法：为了"未来可能的需求"而过度设计
class AuthenticationStrategyFactory {
  // 创建了复杂的抽象层，但当前只需要一种登录方式
}
```

**问题**：
- 没有明确的场景需求
- 为了"未来可能的需求"而增加复杂度
- 增加了理解和维护成本

### 方案输出要求

#### 在输出技术方案时

1. **必须优先考虑简单方案**：
   - 首先提出最简单的实现方案
   - 说明简单方案如何满足当前需求
   - 评估简单方案的局限性

2. **复杂方案必须说明场景**：
   - 如果采用复杂方案，必须明确说明：
     - 在什么场景下需要复杂方案？
     - 简单方案为什么不可行？
     - 复杂方案解决了什么问题？

3. **方案对比**：
   - 对比简单方案和复杂方案
   - 说明各自的优缺点
   - 说明选择理由

#### 方案输出格式

```markdown
## 设计方案

### 方案1：简单方案（推荐）

**实现方式**：[简单方案的描述]

**优点**：
- 实现简单，易于理解
- 维护成本低
- 满足当前需求

**局限性**：
- [如果有局限性，说明]

### 方案2：复杂方案（可选）

**适用场景**：[明确说明在什么场景下需要复杂方案]

**实现方式**：[复杂方案的描述]

**优点**：
- [复杂方案的优势]

**缺点**：
- 实现复杂度高
- 维护成本高
- 学习成本高

**为什么需要复杂方案**：
- 简单方案无法满足 [具体需求]
- 需要支持 [具体场景]
- 有明确的 [约束条件]

### 推荐方案

基于当前需求，推荐使用 [方案1/方案2]，因为 [理由]。
```

### 适用场景

**以下场景必须遵循此规范：**

- ✅ **技术方案设计**：设计技术方案时，优先考虑简单方案
- ✅ **架构设计**：设计系统架构时，避免过度设计
- ✅ **代码实现**：实现功能时，优先使用简单直接的方式
- ✅ **重构决策**：决定是否重构时，评估简单方案是否可行
- ✅ **依赖引入**：引入新依赖时，评估是否必要

### 重要原则

1. **简单优先**：优先考虑最简单的设计方案
2. **场景驱动**：复杂方案必须基于明确的场景和需求
3. **渐进演进**：从简单方案开始，根据实际需求逐步演进
4. **避免假设**：不要为了"未来可能的需求"而增加复杂度
5. **明确说明**：复杂方案必须明确说明使用场景和理由

### 注意事项

1. **强制要求**：所有设计方案必须优先考虑简单方案
2. **场景说明**：复杂方案必须明确说明使用场景
3. **方案对比**：必须对比简单方案和复杂方案
4. **决策记录**：重要设计决策应记录在文档中
5. **定期审查**：定期审查设计，评估是否过度设计

