---
name: problem-location
description: 问题定位与调试规范，包括调试流程、调试代码规范等
tags: [rules, prompt-engine]
---

# 问题定位与调试规范

## 使用场景

当用户需要：
- **应用此规范**时，自动加载此技能

## 触发条件

以下情况自动应用此规范：
- 用户要求应用相关规范时
- AI 助手识别到需要使用此规范时

## 与其他规则的配合

- 与其他规则技能配合使用
- 与核心规则配合使用

---

## 问题定位与调试规范

### 核心原则

**在修改问题之前，必须先定位问题，而不是靠猜测添加各种防御性代码。**

### 强制要求

- **必须先定位问题**：遇到问题时，必须先通过调试手段定位问题的根本原因
- **禁止盲目添加防御**：不能在没有定位问题的情况下，通过添加各种防御性代码来"修复"问题
- **使用调试工具**：优先使用调试工具（如 console、断点、日志等）来定位问题
- **验证假设**：任何对问题的假设都必须通过调试验证，不能仅凭猜测
- **系统性调试**：必须从问题发生的起点开始，逐步追踪数据流，在每个关键节点输出状态
- **一次性修复**：定位到根因后，必须一次性修复，禁止逐个修复表面问题
- **禁止反复定位**：禁止在修复一个问题后，又发现新问题，然后再次修复的循环

### 适用场景说明

**本规范适用于问题排查和修复场景**，不适用于正常代码编写场景。

- ✅ **问题排查场景**：遇到 Bug、功能异常、性能问题等需要排查和修复的场景
- ✅ **问题修复时**：修复已存在的问题时，必须先定位问题，再根据定位结果添加必要的修复代码
- ❌ **正常代码编写**：正常编写新代码或修改现有代码时，错误处理应遵循 `error-handling.md` 规范

**与其他规则的关系**：
- **错误处理规范**（`error-handling.md`）：适用于正常代码编写时的错误处理。定位问题后，应遵循该规范添加必要的错误处理
- **代码风格规范**（`code-style.md`）：修复代码时应遵循代码风格规范

### 关键概念定义

#### 防御性代码的定义

**防御性代码**是指为了处理可能的异常情况、边界条件或错误输入而添加的代码，包括但不限于：

1. **参数验证**：检查函数参数是否有效（如：空值检查、类型检查、范围检查）
2. **错误处理**：捕获和处理可能的错误（如：try-catch、错误回调）
3. **边界条件处理**：处理数据边界情况（如：空数组、空字符串、null/undefined）
4. **类型检查**：检查数据类型是否符合预期（如：typeof、instanceof）
5. **状态检查**：检查对象或系统的状态（如：是否已初始化、是否已加载）

**防御性代码的特征**：
- 处理"可能"发生的情况，而不是"已经"发生的问题
- 通常用于预防问题，而不是修复已定位的问题
- 可能隐藏真正的问题，而不是暴露和修复它

#### 盲目添加防御 vs 定位后添加防御

**盲目添加防御**（禁止）：
- 在没有定位问题的情况下，通过添加防御性代码来"修复"问题
- 不知道问题原因，只是猜测可能的原因并添加防御
- 可能隐藏真正的问题，导致问题反复出现

**定位后添加防御**（允许，但需谨慎）：
- 定位到问题根因后，根据修复方案添加必要的防御性代码
- 明确知道为什么需要添加防御，以及防御要解决什么问题
- 防御性代码是修复方案的一部分，而不是绕过问题

#### 过度防御 vs 合理防御

**过度防御**（禁止）：
- 添加了不必要的防御性代码，这些代码：
  - 处理不可能发生的情况（如：在已经验证过的地方再次验证）
  - 隐藏了真正的问题而不是修复它（如：添加默认值来绕过数据传递问题）
  - 在多个地方重复相同的验证（如：在函数入口和函数内部都验证同一个参数）

**合理防御**（允许）：
- 添加了必要的防御性代码，这些代码：
  - 处理可能发生的边界情况（如：处理外部 API 可能返回 null 的情况）
  - 修复根本原因（如：添加参数验证来修复参数传递问题）
  - 防止类似问题再次发生（如：添加类型检查来防止类型错误）

### 例外情况

以下情况可以跳过定位直接修复，但需要明确说明原因：

#### 例外情况的判断标准

1. **明显的语法错误**：
   - **判断标准**：错误信息明确指向语法问题（如：SyntaxError、ParseError）
   - **示例**：缺少括号、缺少分号、拼写错误
   - **要求**：即使跳过定位，也要简要说明错误类型和修复方式

2. **已知的简单问题**：
   - **判断标准**：问题原因明确，修复方式简单直接（不超过 5 行代码）
   - **示例**：配置项名称错误、路径错误、变量名拼写错误
   - **要求**：必须说明为什么认为是"已知的简单问题"

3. **紧急修复（Hotfix）**：
   - **判断标准**：生产环境紧急问题，需要快速修复
   - **要求**：修复后必须补充定位和验证，确保修复正确

4. **重复出现的问题**：
   - **判断标准**：之前已经定位过相同的问题，有明确的修复方案
   - **要求**：必须说明之前定位的结果和修复方案

**重要原则**：
- ⚠️ 即使是例外情况，也建议先简要定位问题
- ⚠️ 必须明确说明为什么可以跳过详细定位
- ❌ 不能因为"看起来简单"就跳过定位
- ❌ 不能在没有明确判断标准的情况下跳过定位

### 问题定位流程

#### 第一步：收集问题信息

1. **问题现象描述**：
   - 问题发生的具体场景
   - 问题的表现（错误信息、异常行为等）
   - 问题是否可复现
   - 问题发生的频率

2. **环境信息**：
   - 浏览器/运行环境
   - 相关配置
   - 数据状态

#### 第二步：添加调试代码

**核心原则**：系统性调试，追踪完整数据流

**重要约束**：在问题分析阶段，**只添加日志，不要修改代码逻辑，也不要添加防御性代码**

在关键位置添加调试代码，用于定位问题：

**调试代码添加策略**：

1. **从问题起点开始**：
   - 从问题发生的入口函数/脚本开始
   - 逐步追踪数据流，在每个关键节点添加调试信息
   - 确保能够完整追踪从输入到输出的数据流

2. **关键节点识别**：
   - 函数/脚本入口和出口
   - 数据读取/写入点
   - 条件判断点
   - 数据转换点（如 JSON 解析、字符串处理等）
   - 外部调用点（如调用其他函数、脚本、API 等）

3. **数据流追踪**：
   - 追踪关键变量的值变化
   - 追踪数据结构的变化
   - 追踪数据传递过程（如函数参数、返回值、环境变量、管道传递等）

**问题分析阶段的约束**（强制要求）：

- ✅ **允许的操作**：
  - 添加日志输出（console.info、console.error、logger 等）
  - 添加临时变量用于观察数据
  - 添加注释说明调试目的
  - 使用断点或调试工具

- ❌ **禁止的操作**：
  - ❌ **禁止修改代码逻辑**：不能改变原有的执行流程、条件判断、函数调用等
  - ❌ **禁止添加防御性代码**：不能添加参数验证、错误处理、边界检查等防御性代码
  - ❌ **禁止修改业务逻辑**：不能修改函数的核心业务逻辑
  - ❌ **禁止添加修复代码**：不能添加任何试图"修复"问题的代码

**原因说明**：
- 问题分析阶段的目的是**定位问题**，而不是修复问题
- 修改代码逻辑会改变程序行为，可能掩盖真正的问题
- 添加防御性代码会隐藏问题，而不是暴露问题
- 只有定位到问题根因后，才能制定修复方案并修改代码

**示例**：

```javascript
// ✅ 好的做法：只添加日志，不修改逻辑
function processData(data) {
  console.info('[问题定位] 函数入口', { data, dataType: typeof data });
  // 原有代码逻辑保持不变
  const result = data.map(item => item.value);
  console.info('[问题定位] 处理结果', { result, resultLength: result.length });
  return result;
}

// ❌ 不好的做法：修改了代码逻辑
function processData(data) {
  // ❌ 错误：添加了防御性代码（修改了逻辑）
  if (!data) {
    return [];
  }
  // ❌ 错误：修改了原有逻辑
  const result = data.map(item => item.value || 0);  // 添加了默认值
  return result;
}
```

1. **使用 console.info 输出关键信息**：
   ```javascript
   // 在问题发生的关键位置添加 console.info
   console.info('[问题定位] 函数入口', { param1, param2 });
   console.info('[问题定位] 中间状态', { state1, state2 });
   console.info('[问题定位] 函数出口', { result });
   ```
   
   **优先使用 `console.info`**：
   - `console.info` 专门用于输出信息性日志，语义更清晰
   - 在浏览器控制台中，`console.info` 通常有特殊的图标标识，便于区分
   - 与 `console.log` 功能相同，但语义更明确，推荐使用

2. **输出关键变量值**：
   ```javascript
   // 输出可能相关的变量值
   console.info('[问题定位] 变量值', {
     variable1: variable1,
     variable2: variable2,
     data: JSON.stringify(data, null, 2)
   });
   ```

3. **输出执行流程**：
   ```javascript
   // 标记执行流程
   console.info('[问题定位] 步骤1: 开始执行');
   // ... 代码逻辑
   console.info('[问题定位] 步骤2: 执行中间逻辑');
   // ... 代码逻辑
   console.info('[问题定位] 步骤3: 执行完成');
   ```

4. **输出条件判断**：
   ```javascript
   // 在条件判断处输出条件值
   console.info('[问题定位] 条件判断', {
     condition1: condition1,
     condition2: condition2,
     result: condition1 && condition2
   });
   ```

5. **输出错误信息**：
   ```javascript
   // 在错误处理处输出详细信息
   try {
     // 可能出错的代码
   } catch (error) {
     console.error('[问题定位] 错误信息', {
       error: error.message,
       stack: error.stack,
       context: { /* 相关上下文信息 */ }
     });
   }
   ```

#### 第三步：运行并观察

1. **运行代码**：执行包含调试代码的程序
2. **观察输出**：查看控制台输出，分析问题发生的位置和原因
3. **对比预期**：将实际输出与预期结果对比，找出差异点

#### 第四步：分析问题根因

1. **定位问题位置**：根据调试输出，确定问题发生的具体位置
2. **分析问题原因**：分析为什么会出现这个问题
3. **验证假设**：对问题原因进行验证，确保分析正确
4. **识别根本原因**：
   - 区分表面问题和根本原因
   - 避免只修复表面现象，导致问题反复出现
   - 如果发现多个问题，分析它们之间的关系，找出根本原因
5. **数据流分析**：
   - 分析数据在哪个环节丢失或变化
   - 分析数据传递方式是否正确（如管道传递、环境变量传递等）
   - 分析数据格式是否正确（如 JSON 解析、字符串编码等）

#### 第五步：制定修复方案

1. **基于根因修复**：根据定位到的问题根因，制定针对性的修复方案
2. **定位后添加防御的规则**：
   - **允许的情况**：定位到问题根因后，如果修复方案需要添加防御性代码来：
     - 修复根本原因（如：添加参数验证来修复参数传递问题）
     - 处理边界情况（如：添加空值检查来处理数据可能为空的情况）
     - 防止类似问题（如：添加类型检查来防止类型错误）
   - **禁止的情况**：定位到问题根因后，不应该添加防御性代码来：
     - 隐藏真正的问题（如：添加 try-catch 来捕获错误但不处理）
     - 绕过根本原因（如：添加默认值来绕过数据传递问题）
     - 添加不必要的防御（如：在已经验证过的地方再次验证）
   - **错误处理规范**：定位问题后，如果需要添加错误处理代码（如 try-catch、错误日志等），应遵循 `error-handling.md` 规范，确保错误处理机制统一、完整
3. **避免过度防御**：
   - **过度防御的定义**：添加了不必要的防御性代码，这些代码：
     - 处理不可能发生的情况
     - 在已经验证过的地方重复验证
     - 隐藏了真正的问题而不是修复它
   - **合理防御的定义**：添加了必要的防御性代码，这些代码：
     - 处理可能发生的边界情况
     - 修复根本原因
     - 防止类似问题再次发生
4. **一次性修复**：
   - 定位到根因后，制定完整的修复方案
   - 一次性修复所有相关问题，避免修复一个问题后又发现新问题
   - 如果发现多个问题，分析它们之间的关系，优先修复根本原因
4. **验证修复效果**：修复后，通过调试代码验证问题是否解决
5. **清理调试代码**：问题解决后，清理临时添加的调试代码（保留关键日志可选项）

### 调试代码规范

#### 调试代码格式

1. **统一前缀**：使用统一的前缀标识调试日志，如 `[问题定位]`、`[调试]` 等
2. **结构化输出**：使用对象形式输出，便于查看和分析
3. **关键信息**：输出足够的信息，但避免输出敏感信息

#### 调试代码示例

```javascript
// ✅ 好的调试代码：使用 console.info
console.info('[问题定位] 函数执行', {
  functionName: 'processData',
  input: { param1, param2 },
  step: '开始处理'
});

// ✅ 好的调试代码：使用 console.info 输出变量值
console.info('[问题定位] 变量值', {
  variable1: variable1,
  variable2: variable2
});

// ❌ 不好的调试代码
console.log('debug'); // 信息不足
console.log(param1, param2, param3); // 没有结构化
```

#### console.info 使用说明

**优先使用 `console.info` 进行问题定位**：

1. **语义清晰**：
   - `console.info` 专门用于输出信息性日志，语义更明确
   - 与 `console.log` 功能相同，但更适合用于调试和问题定位

2. **浏览器支持**：
   - 所有现代浏览器都支持 `console.info`
   - 在浏览器控制台中，`console.info` 通常有特殊的图标标识（如信息图标），便于区分

3. **使用场景**：
   - ✅ **问题定位**：使用 `console.info` 输出调试信息
   - ✅ **流程跟踪**：使用 `console.info` 跟踪执行流程
   - ✅ **变量值输出**：使用 `console.info` 输出变量值
   - ✅ **条件判断**：使用 `console.info` 输出条件判断结果

4. **与其他 console 方法的区别**：
   - `console.info`：信息性日志，用于问题定位和调试
   - `console.log`：通用日志，功能与 `console.info` 相同，但语义不如 `console.info` 明确
   - `console.warn`：警告信息，用于输出警告
   - `console.error`：错误信息，用于输出错误
   - `console.debug`：调试信息，用于详细调试（通常需要开启调试模式）

5. **推荐用法**：
   ```javascript
   // ✅ 推荐：使用 console.info 进行问题定位
   console.info('[问题定位] 函数入口', { param1, param2 });
   console.info('[问题定位] 中间状态', { state });
   console.info('[问题定位] 函数出口', { result });
   
   // ✅ 推荐：使用 console.error 输出错误
   console.error('[问题定位] 错误信息', { error });
   
   // ✅ 推荐：使用 console.warn 输出警告
   console.warn('[问题定位] 警告信息', { warning });
   ```

#### 调试代码清理

1. **临时调试代码**：问题定位完成后，应清理临时添加的调试代码
2. **保留关键日志**：如果调试代码对后续维护有帮助，可以保留并添加注释说明
3. **生产环境**：确保生产环境不包含调试代码，或通过环境变量控制

### 禁止的做法

#### ❌ 禁止盲目添加防御性代码

```javascript
// ❌ 不好的做法：没有定位问题，直接添加防御
function processData(data) {
  // 不知道 data 为什么可能是 undefined，直接添加防御
  if (!data) {
    return; // 这样可能隐藏了真正的问题
  }
  // ...
}

// ✅ 好的做法：先定位问题，再修复
function processData(data) {
  console.info('[问题定位] processData 调用', { data, caller: new Error().stack });
  // 通过调试发现 data 在某个调用路径下是 undefined
  // 修复调用方，确保传入正确的 data
  // ...
}
```

#### ✅ 定位后可以添加防御的情况

```javascript
// ✅ 好的做法：定位到问题后，添加必要的防御
function processData(data) {
  // 第一步：定位问题
  console.info('[问题定位] processData 调用', { data, caller: new Error().stack });
  // 通过调试发现：data 在某个调用路径下可能是 undefined，因为调用方没有验证
  
  // 第二步：分析根因
  // 根因：调用方没有验证数据，导致传入 undefined
  
  // 第三步：制定修复方案
  // 方案1：修复调用方（优先）
  // 方案2：在当前函数添加防御（如果无法修复调用方）
  
  // 第四步：实施修复（如果无法修复调用方，添加防御）
  if (!data) {
    console.warn('[问题定位] processData 收到无效数据，调用方：', new Error().stack);
    throw new Error('data 不能为空');
  }
  // ...
}
```

#### ❌ 定位后禁止添加防御的情况

```javascript
// ❌ 不好的做法：定位到问题后，添加防御来隐藏问题
function processData(data) {
  // 定位到问题：data 在某个调用路径下是 undefined
  // 根因：调用方没有验证数据
  
  // ❌ 错误：添加防御来隐藏问题，而不是修复调用方
  if (!data) {
    return; // 隐藏了问题，调用方仍然会传入 undefined
  }
  // ...
}

// ✅ 好的做法：修复根本原因
function processData(data) {
  // 定位到问题：data 在某个调用路径下是 undefined
  // 根因：调用方没有验证数据
  
  // ✅ 正确：修复调用方，确保传入正确的 data
  // 在调用方添加验证：
  // if (!data) {
  //   throw new Error('data 不能为空');
  // }
  // processData(data);
}
```

#### ❌ 禁止猜测问题原因

```javascript
// ❌ 不好的做法：猜测问题原因
function handleError(error) {
  // 猜测可能是网络问题，添加重试逻辑
  if (error.message.includes('network')) {
    retry();
  }
  // 猜测可能是超时，添加延迟
  if (error.message.includes('timeout')) {
    setTimeout(() => retry(), 1000);
  }
}

// ✅ 好的做法：先定位问题
function handleError(error) {
  console.error('[问题定位] 错误详情', {
    error: error.message,
    stack: error.stack,
    context: getErrorContext()
  });
  // 根据实际错误信息，制定针对性的处理方案
}
```

#### ❌ 禁止添加不必要的 try-catch

```javascript
// ❌ 不好的做法：到处添加 try-catch，隐藏问题
function processData(data) {
  try {
    // 不知道哪里可能出错，全部包起来
    const result = data.map(item => item.value);
    return result;
  } catch (error) {
    console.error(error);
    return [];
  }
}

// ✅ 好的做法：先定位问题，再添加必要的错误处理
function processData(data) {
  console.info('[问题定位] processData', { data });
  // 通过调试发现 data.map 可能出错，因为 data 可能是 null
  // 修复调用方，确保传入正确的 data
  const result = data.map(item => item.value);
  return result;
}
```

#### ❌ 禁止反复定位和逐个修复

```bash
# ❌ 不好的做法：反复定位，逐个修复表面问题
# 第一次：添加环境变量传递（猜测是环境变量问题）
export RULES_REPO
# 第二次：修复管道传递（发现新问题）
# 第三次：修复颜色显示（又发现新问题）
# 第四次：修复路径截断（又发现新问题）
# 问题：每次只修复表面问题，没有一次性定位根本原因

# ✅ 好的做法：系统性调试，一次性定位根因
# 第一步：在关键位置添加调试信息
echo "[问题定位] RULES_REPO=${RULES_REPO}" >&2
echo "[问题定位] projects_json 长度=${#projects_json}" >&2
echo "[问题定位] project_paths 数量=${#project_paths[@]}" >&2

# 第二步：运行并观察，找出数据流中断的位置
# 第三步：根据调试输出，定位根本原因（如：管道传递 JSON 时内容丢失）
# 第四步：一次性修复根本原因（使用环境变量传递 JSON）
```

#### ❌ 禁止分散的调试信息

```bash
# ❌ 不好的做法：调试信息分散，没有系统性
echo "DEBUG: 这里有问题"  # 不知道具体是什么问题
echo "DEBUG: 变量值: $var"  # 不知道变量应该是什么值
echo "DEBUG: 执行到这里"  # 不知道执行流程

# ✅ 好的做法：系统性调试，追踪数据流
echo "[问题定位] 函数入口" >&2
echo "[问题定位] 输入参数: $1" >&2
echo "[问题定位] 读取配置文件: $config_file" >&2
echo "[问题定位] 配置文件内容长度: ${#config_content}" >&2
echo "[问题定位] 解析后项目数量: ${#projects[@]}" >&2
echo "[问题定位] 函数出口，返回值: $result" >&2
```

### 调试工具使用

#### 浏览器调试工具

1. **Console**：
   - **优先使用 `console.info`**：用于输出信息性日志，进行问题定位
   - `console.error`：用于输出错误信息
   - `console.warn`：用于输出警告信息
   - `console.debug`：用于输出详细调试信息（需要开启调试模式）
   - `console.log`：通用日志，功能与 `console.info` 相同，但推荐使用 `console.info`
2. **断点调试**：使用 `debugger` 语句或浏览器开发者工具设置断点
3. **Network**：查看网络请求，分析接口调用
4. **Sources**：查看源代码，设置断点，单步调试

#### Node.js 调试工具

1. **console**：
   - **优先使用 `console.info`**：用于输出信息性日志，进行问题定位
   - `console.error`：用于输出错误信息
   - `console.warn`：用于输出警告信息
   - `console.log`：通用日志，功能与 `console.info` 相同，但推荐使用 `console.info`
2. **debugger**：使用 `debugger` 语句配合 `node --inspect` 调试
3. **日志文件**：将调试信息输出到日志文件

#### 其他调试工具

1. **日志系统**：使用项目中的日志系统记录调试信息
2. **性能分析**：使用性能分析工具定位性能问题
3. **错误监控**：使用错误监控工具收集错误信息

### 适用场景

**以下场景必须遵循此规范：**

- ✅ **Bug 修复**：修复 Bug 时，必须先定位问题
- ✅ **功能异常**：功能异常时，必须先定位问题
- ✅ **性能问题**：性能问题时，必须先定位瓶颈
- ✅ **数据异常**：数据异常时，必须先定位数据流
- ✅ **接口问题**：接口问题时，必须先定位调用链
- ✅ **任何问题修复**：任何问题修复前，都必须先定位问题

**以下场景可以例外（但仍建议先定位）：**

- ⚠️ **明显的语法错误**：如拼写错误、缺少括号、缺少分号等（可以直接修复，但建议验证修复正确）
- ⚠️ **已知的简单问题**：如配置项名称错误、路径错误等（可以直接修复，但建议验证修复正确）
- ⚠️ **紧急修复（Hotfix）**：生产环境紧急问题，需要快速修复（可以先修复，但修复后必须补充定位和验证）
- ⚠️ **重复出现的问题**：如果之前已经定位过相同的问题，可以直接修复（但建议验证修复正确）

### 重要原则

1. **定位优先**：问题定位优先于问题修复
2. **调试工具**：优先使用调试工具定位问题
3. **验证假设**：任何假设都必须通过调试验证
4. **根因修复**：基于问题根因进行修复，避免过度防御
5. **代码质量**：保持代码质量，避免添加不必要的防御性代码
6. **系统性调试**：从问题起点开始，逐步追踪数据流，在每个关键节点输出状态
7. **一次性修复**：定位到根因后，一次性修复所有相关问题，避免反复定位
8. **数据流追踪**：重点关注数据传递过程（函数参数、返回值、环境变量、管道传递等）

### 注意事项

1. **调试代码规范**：调试代码应遵循统一的格式和规范
2. **调试代码清理**：问题定位完成后，应及时清理临时调试代码
3. **生产环境**：确保生产环境不包含调试代码
4. **敏感信息**：调试代码中不应输出敏感信息
5. **性能影响**：调试代码不应影响生产环境性能
6. **避免反复定位**：如果修复一个问题后又发现新问题，说明没有定位到根本原因，需要重新系统性调试
7. **数据流完整性**：确保调试信息能够完整追踪数据流，从输入到输出的每个环节

### 常见问题场景

#### 场景1：反复定位问题

**问题表现**：
- 修复一个问题后，又发现新问题
- 多次修复，问题仍然存在或反复出现
- 调试信息分散，无法系统性地追踪问题

**正确做法**：
1. **停止修复**：停止当前的修复尝试
2. **重新系统性调试**：从问题起点开始，添加完整的调试信息
3. **追踪数据流**：追踪从输入到输出的完整数据流
4. **定位根本原因**：找出所有问题的根本原因
5. **一次性修复**：根据根本原因，制定完整的修复方案

#### 场景2：数据传递问题

**常见问题**：
- 环境变量未传递
- 管道传递时数据丢失
- JSON 解析失败
- 字符串编码问题

**调试方法**：
1. **在数据传递的起点和终点添加调试信息**：
   ```bash
   echo "[问题定位] 数据传递起点: $data" >&2
   # ... 数据传递过程
   echo "[问题定位] 数据传递终点: $received_data" >&2
   ```
2. **检查数据格式**：验证数据格式是否正确（如 JSON 格式、字符串编码等）
3. **检查传递方式**：验证传递方式是否正确（如环境变量、管道、文件等）

#### 场景3：多个相关问题

**问题表现**：
- 发现多个问题，但不知道它们之间的关系
- 修复一个问题后，另一个问题出现

**正确做法**：
1. **系统性调试**：对所有相关问题进行系统性调试
2. **分析关系**：分析问题之间的关系，找出根本原因
3. **优先级排序**：根据根本原因，确定修复优先级
4. **一次性修复**：制定完整的修复方案，一次性修复所有相关问题
