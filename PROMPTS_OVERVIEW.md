# 提示词概述文档

> **文档说明**：本文档提供项目中所有提示词模板的完整概述，包括每个提示词的描述和应用场景
> **创建时间**：2025-12-15
> **最后更新**：2025-12-19

---

## 📋 目录

- [项目概述](#项目概述)
- [通用阶段提示词](#通用阶段提示词)
  - [模式规则](#模式规则)
  - [代码规范](#代码规范)
  - [文档规范](#文档规范)
  - [交互规范](#交互规范)
  - [项目规范](#项目规范)
- [研发阶段提示词](#研发阶段提示词)
- [项目类型提示词](#项目类型提示词)
- [模板文件](#模板文件)

---

## 项目概述

本项目是一个提示词工程管理系统，包含按阶段和类型组织的提示词模板。所有提示词模板均通过合并脚本自动合并到 `.cursorrules` 文件中使用。

### 提示词分类

1. **按阶段组织** (`stages/`)：按研发流程的不同阶段分类
2. **按类型组织** (`types/`)：按项目类型（前端/后端/全栈/移动端）分类
3. **通用模板** (`templates/`)：可复用的通用提示词模板

---

## 通用阶段提示词

通用阶段提示词适用于所有研发阶段，包含以下模块：

---

## 模式规则

模式规则定义了 AI 助手在不同模式下的行为规范，包括 Plan 模式（计划模式）、Act 模式（执行模式）以及通用规则和安全规则。

### 方案输出和计划

#### 1. Plan 模式行为规范 (`behavior.md`)

**描述**：定义 Plan 模式的基础行为规范，包括允许和禁止的操作、执行意图确认机制、输出规范等。

**应用场景**：
- 用户描述问题或需求时，AI 需要明确当前处于 Plan 模式
- 需要区分计划输出和实际执行操作
- 用户要求创建文件时，需要先输出内容再提醒切换模式
- 输出长内容前需要确认用户是否需要完整输出

**核心要点**：
- 默认以 Plan 模式开始
- 只能读取、搜索、查看，不能修改文件
- 可以创建 TODO 列表记录计划，但不能立即执行
- 输出前需要确认机制，避免输出过长内容

**如何提问**：
- 直接描述问题或需求，AI 会自动进入 Plan 模式
- 示例："我需要修改 `src/utils.js` 中的 `formatDate` 函数"
- 示例："请分析 `config.json` 文件的结构"
- 示例："帮我查看 `README.md` 文件的内容"

---

#### 2. 工具权限系统 (`tool-permission-system.md`) ⭐⭐⭐ 核心规则

**描述**：工具权限系统的顶层规则文件，定义工具分类体系、统一检查流程、意图识别机制、禁止行为等。**本文件是工具调用检查的唯一入口**。

**应用场景**：
- 每次调用工具前必须执行此检查
- 确保 Plan 模式下不调用文件修改工具
- 确保 Act 模式下方案完整才执行修改
- 防止跳过检查直接调用工具
- 意图识别失败时需要与用户确认

**核心要点**：
- **工具分类体系**：只读工具 vs 修改工具
- **统一检查流程（4步）**：
  - 第零步：意图识别检查（仅修改工具）- 判断用户是否有修改需求，失败时强制与用户确认
  - 第一步：工具分类判断 - 判断工具类型（只读工具 or 修改工具）
  - 第二步：权限检查 - 根据工具类型和模式判断权限
  - 第三步：方案完整性检查（仅修改工具 + Act 模式）- 检查方案是否完整
- **意图识别机制**：
  - 关键词匹配和上下文分析
  - 不确定时询问用户意图
  - 识别失败时触发安全机制（统一使用 Plan 模式，强制与用户确认）
  - 重新识别次数限制（最多 2 次，避免无限循环）
- **禁止行为清单**：统一列出所有禁止的行为（Plan 模式、Act 模式、通用禁止行为）

**如何提问**：
- 直接描述修改需求，AI 会自动执行检查机制
- 示例："修改 `src/api.js` 添加错误处理"
- 示例："在 `utils/helper.js` 中添加新函数"
- 注意：在 Plan 模式下，AI 会先输出方案，等待你输入 "Act" 后才执行
- 如果意图识别失败，AI 会与您确认需求，请明确回复您的选项（A/B/C）

---

#### 3. 代码修改前的方案输出机制 (`solution-output.md`)

**描述**：在 Plan 模式下，收到任何代码修改需求时，必须先输出详细的修改方案和计划，等待用户确认后才能执行。

**应用场景**：
- 用户明确要求修改代码
- 用户描述问题但可能涉及代码修改
- 用户描述功能需求但需要代码实现
- 任何可能调用文件修改工具的情况

**核心要点**：
- 必须输出 5 个部分：需求分析、修改方案、影响分析、实施计划、风险评估
- 必须输出任务清单（表格格式）
- 必须等待用户输入 "Act" 指令
- **方案完整性判断标准**：已整合到本文件中（原 `solution-completeness.md`）
- **意图识别**：在工具调用检查时执行（详见 `tool-permission-system.md`）

**如何提问**：
- 使用明确的修改需求关键词：修改、添加、删除、实现、修复等
- 示例："修改 `src/api.js` 中的 `fetchData` 函数，添加重试机制"
- 示例："实现用户登录功能，包含用户名和密码验证"
- 示例："修复 `utils/validator.js` 中的类型检查问题"
- AI 会自动输出完整方案，等待你输入 "Act" 后执行

---

#### 4. 问题修复处理 (`problem-fix.md`)

**描述**：问题修复场景的特殊处理，确保修复前先定位问题。

**应用场景**：
- 用户报告 Bug 或功能异常
- 需要修复已存在的问题
- 问题修复时需要特殊处理流程

**核心要点**：
- 修复前必须先定位问题
- 遵循问题定位规范
- 不能盲目添加防御性代码

**如何提问**：
- 描述问题时，AI 会自动先定位问题再修复
- 示例："`login` 函数返回 undefined，请修复"
- 示例："页面加载时出现错误，请检查并修复"
- 示例："数据提交失败，需要定位问题原因"
- AI 会先添加调试代码定位问题，再输出修复方案

---

#### 5. 例外情况处理 (`exception-handling.md`)

**描述**：例外情况的处理流程，明确哪些情况可以例外处理。

**应用场景**：
- 遇到特殊情况需要例外处理
- 需要判断是否符合例外条件
- 例外情况的处理流程

**核心要点**：
- 明确例外情况的判断标准
- 例外情况需要明确说明原因
- 例外处理不能违反核心原则

---

#### 6. 方案模块化输出 (`modular-output.md`)

**描述**：完整方案模块化输出策略，将复杂方案拆分为多个模块输出。

**应用场景**：
- 方案内容较多，需要分模块输出
- 复杂工程需要模块化展示
- 提高方案的可读性和可维护性

**核心要点**：
- 按模块拆分方案
- 每个模块独立完整
- 模块之间有清晰的依赖关系

---

#### 7. 兼容性确认机制 (`compatibility-check.md`)

**描述**：技术方案调整的兼容性确认机制，确保方案调整不影响现有功能。

**应用场景**：
- 技术方案需要调整时
- 需要确认调整的兼容性
- 评估调整对现有功能的影响

**核心要点**：
- 调整前需要评估兼容性
- 需要确认向下兼容
- 提供迁移方案（如需要）

---

### 代码执行和文件操作

#### 8. Act 模式行为规范 (`behavior.md`)

**描述**：定义 Act 模式的基础行为规范，包括执行前的计划确认、执行过程中的问题处理等。

**应用场景**：
- 用户输入 "Act" 指令后进入执行模式
- 执行实际代码修改前需要确认计划
- 执行过程中发现方案有问题时的处理

**核心要点**：
- 执行前必须先确认计划
- 执行后自动返回 Plan 模式
- 发现方案有问题时必须停止并返回 Plan 模式

---

#### 9. 文件写入规则 (`file-write.md`)

**描述**：文件写入规则，优先写入框架，然后再补充内容。

**应用场景**：
- 创建新文件时
- 写入复杂文件内容时
- 文件内容超过 200 行或 10KB 时

**核心要点**：
- 优先写入文件框架结构
- 再逐步填充内容
- 大文件必须分步写入

---

#### 10. 时间字段检查 (`time-check.md`)

**说明**：长文本写入检查已整合到 `file-write.md` 中，作为文件写入前的第一步检查。

**描述**：时间字段强制检查机制，创建包含时间字段的文档时必须先获取当前时间。

**应用场景**：
- 创建包含时间字段的文档（如创建时间、更新时间）
- 需要填写日期时
- 避免使用假设或硬编码的时间

**核心要点**：
- 必须先运行 `date` 命令获取当前时间
- 禁止使用具体日期（如 `2025-01-21`）
- 禁止使用格式占位符（如 `YYYY-MM-DD`）
- 禁止使用模糊表述（如"今天"、"当前日期"）

---

#### 11. 分阶段实施规则 (`phase-implementation.md`)

**描述**：大型工程分阶段实施规则，每个阶段完成后确认和测试再继续。

**应用场景**：
- 阶段数量超过 2 个
- 任务数量超过 5 个
- 需要创建/修改 5 个以上文件
- 单个文件超过 500 行
- 预计总代码量超过 1000 行

**核心要点**：
- 按任务数量、功能模块、依赖关系或复杂度划分阶段
- 每个阶段 2-4 个任务
- 阶段完成后询问是否需要测试
- 测试通过后再继续下一阶段

---

### 模式切换和响应格式

#### 12. 模式通用规则 (`mode-common.md`)

**描述**：模式切换、响应格式等通用规则，适用于所有模式。

**应用场景**：
- 模式切换时（Plan ↔ Act）
- 响应格式规范
- Act 模式下新需求的识别和处理
- 模式切换前的方案完整性检查

**核心要点**：
- Plan → Act：只有用户输入 "Act" 指令才能切换
- Act → Plan：执行完成后自动返回
- 每次响应开头必须标明当前模式
- Act 模式下识别新需求时必须返回 Plan 模式

---

### 工具调用和安全检查

#### 13. 大文件读取策略 (`file-reading.md`)

**描述**：定义大文件的读取策略，采用阶段性读取避免一次性读取整个文件。

**应用场景**：
- 读取超过 1000 行或 50KB 的文件
- 需要分析文件结构或特定部分
- 文件内容包含大量重复或无关信息

**核心要点**：
- 先读取文件头部（50-100 行）了解结构
- 按需分块读取（每次 200-500 行）
- 优先使用搜索工具定位，只读取相关部分

---

#### 14. 安全权限规则 (`security-permissions.md`)

**描述**：系统化整理 AI 的安全规则和权限规则，明确哪些可以做、哪些不可以做、哪些需要确认。

**应用场景**：
- 快速查找权限规则
- 判断某个操作是否允许
- 需要确认的操作流程
- 权限升级机制

**核心要点**：
- 模式权限矩阵（Plan/Act 模式的权限对比）
- 工具权限分类（可以做/不可以做/需要确认）
- 行为权限分类
- 安全检查机制（快速参考，详细说明见 `tool-permission-system.md`）
- 权限升级机制

---

## 代码规范

代码规范定义了代码编写、格式、命名等方面的标准。

### 命名规范

#### 19. 命名规范 (`naming.md`)

**描述**：变量、函数、类、常量、文件的命名规范，确保命名清晰、语义明确。

**应用场景**：
- 编写新代码时遵循命名规范
- 代码审查时检查命名是否符合规范
- 重构代码时统一命名风格

**核心要点**：
- 使用完整单词，避免缩写（标准缩写如 API、URL 除外）
- 变量和函数使用 `lowerCamelCase`
- 类名使用 `UpperCamelCase`
- 常量使用全大写字母，单词间以下划线分隔
- 文件命名遵循项目规范（kebab-case、camelCase 或 PascalCase）

**如何提问**：
- 明确要求遵循命名规范
- 示例："创建新函数，遵循命名规范"
- 示例："检查代码中的命名是否符合规范"
- 示例："重构变量名，使用规范的命名方式"
- 也可以直接编写代码，AI 会自动检查命名规范

---

### 函数设计规范

#### 20. 函数设计规范 (`function-design.md`)

**描述**：函数设计原则、命名、参数处理等规范，确保函数简短、单一用途、易于理解。

**应用场景**：
- 编写新函数时遵循设计原则
- 重构复杂函数时拆分函数
- 代码审查时检查函数设计

**核心要点**：
- 函数应简短且单一用途，指令数量少于 20 条
- 函数名称应包含动词，清晰表达功能
- 避免代码块嵌套，使用尽早返回或提取函数
- 根据函数复杂度选择合适的函数类型（箭头函数或命名函数）

---

### 代码格式规范

#### 21. 代码格式规范 (`code-format.md`)

**描述**：缩进、行长度、空行、导入、括号和空格等格式规范，确保代码格式统一。

**应用场景**：
- 编写代码时遵循格式规范
- 代码格式化时统一格式
- 代码审查时检查格式

**核心要点**：
- 使用 4 个空格缩进，不使用制表符
- 每行代码不超过 80 个字符
- 函数之间使用一个空行分隔
- 类之间使用两个空行分隔
- 导入语句按字母顺序排列

---

### 注释规范

#### 22. 注释规范 (`comments.md`)

**描述**：单行、多行、文档、TODO 注释规范，确保注释清晰、及时更新。

**应用场景**：
- 编写代码时添加注释
- 代码审查时检查注释质量
- 重构代码时更新注释

**核心要点**：
- 使用完整的句子进行注释，首字母大写，句末加句号
- 注释应清晰表达代码的意图和逻辑
- 代码修改时同步更新相关注释
- 避免注释与代码重复，注释应解释"为什么"而不是"是什么"
- 函数和类应包含文档注释（JSDoc 格式）

---

### 错误处理规范

#### 23. 错误处理策略 (`strategy.md`)

**描述**：错误处理策略、异常捕获、错误边界等规范，确保所有可能的错误情况都被捕获和处理。

**应用场景**：
- 编写新代码时设计错误处理机制
- 修复 Bug 时添加必要的错误处理
- 代码审查时检查错误处理是否完善

**核心要点**：
- 实现统一的错误处理机制
- 捕获异常时指定具体的异常类型，避免使用通用的 `except`
- 所有可能引发异常的代码块应使用 `try-except` 处理
- 合理处理错误传播，避免错误被忽略或隐藏
- 错误处理应在代码设计时考虑，而非问题修复时盲目添加

---

#### 24. 错误日志记录 (`logging.md`)

**描述**：错误日志记录规范，确保日志信息详细、结构化、便于分析。

**应用场景**：
- 记录错误信息时遵循日志规范
- 配置日志系统时设置日志级别
- 分析错误日志时查找问题

**核心要点**：
- 使用统一的日志记录库
- 根据事件重要性设置日志级别（DEBUG、INFO、WARNING、ERROR、CRITICAL）
- 记录详细的错误信息：时间戳、模块名称、错误类型、错误消息、堆栈信息、上下文信息
- 使用结构化日志格式，便于日志分析和查询

---

#### 25. 错误信息格式 (`message-format.md`)

**描述**：错误信息格式规范，确保错误信息清晰、有用、便于理解。

**应用场景**：
- 抛出异常时格式化错误信息
- 返回错误响应时格式化错误消息
- 显示错误给用户时格式化错误提示

**核心要点**：
- 错误信息应清晰描述问题
- 包含必要的上下文信息
- 使用统一的错误信息格式
- 避免技术术语，使用用户友好的语言

---

#### 26. 返回值规范 (`return-values.md`)

**描述**：返回值规范，确保函数返回值类型明确、含义清晰。

**应用场景**：
- 编写函数时定义返回值
- 代码审查时检查返回值是否规范
- 重构函数时统一返回值格式

**核心要点**：
- 返回值类型应明确
- 返回值含义应清晰
- 使用统一的返回值格式
- 错误情况应返回明确的错误值或抛出异常

---

### 代码组织规范

#### 27. 代码组织规范 (`code-organization.md`)

**描述**：文件大小限制、拆分原则等规范，保持代码文件职责单一，控制文件大小。

**应用场景**：
- 创建新文件时控制文件大小
- 文件过大时拆分文件
- 代码审查时检查文件组织

**核心要点**：
- 新增文件的代码行数不得超过 500 行
- 每个文件应只负责一个明确的功能或职责
- 超过 500 行的历史文件，新增代码应放到新文件
- 按功能、层次或职责拆分文件

---

### 问题定位规范

#### 28. 问题定位规范 (`problem-location.md`)

**描述**：问题定位与调试规范，在修改问题之前必须先定位问题，而不是靠猜测添加各种防御性代码。

**应用场景**：
- 遇到 Bug 或功能异常时定位问题
- 修复问题前必须先定位根本原因
- 调试代码时遵循定位规范

**核心要点**：
- **必须先定位问题**：遇到问题时，必须先通过调试手段定位问题的根本原因
- **禁止盲目添加防御**：不能在没有定位问题的情况下，通过添加各种防御性代码来"修复"问题
- **使用调试工具**：优先使用调试工具（如 console、断点、日志等）来定位问题
- **系统性调试**：必须从问题发生的起点开始，逐步追踪数据流，在每个关键节点输出状态
- **一次性修复**：定位到根因后，必须一次性修复，禁止逐个修复表面问题

**如何提问**：
- 描述问题时，AI 会自动先定位问题再修复
- 示例："`getUserData` 函数返回 null，请定位问题并修复"
- 示例："页面渲染失败，需要先定位根本原因"
- 示例："数据传递过程中丢失，请追踪数据流定位问题"
- 明确要求："先定位问题，再输出修复方案"
- AI 会添加调试代码（使用 `console.info`）追踪问题，定位后再修复

---

## 文档规范

文档规范定义了文档格式、时间格式等标准。

### 29. 文档格式规范 (`document-format.md`)

**描述**：文档输出格式规范，确保文档结构清晰、格式统一、便于阅读和维护。

**应用场景**：
- 输出任务清单时使用表格格式
- 生成文档时遵循格式规范
- 创建文档时避免默认添加 QA 部分

**核心要点**：
- 任务清单必须使用表格形式展示
- 文档结构遵循金字塔原理（总分总）
- 禁止默认添加 QA 部分（除非用户明确要求）
- 按需输出，只输出用户明确要求的内容
- 代码输出限制：非开发环境，没有明确指令不要输出代码

**如何提问**：
- 明确要求生成文档或任务清单
- 示例："生成项目开发任务清单，使用表格格式"
- 示例："创建技术方案文档，遵循总分总结构"
- 示例："输出实施计划，包含任务清单表格"
- 注意：AI 不会默认添加 QA 部分，除非你明确要求

---

### 30. 时间格式规范 (`time-format.md`)

**描述**：时间格式规范，所有时间字段都必须通过工具动态获取，严禁使用任何假设时间。

**应用场景**：
- 创建包含时间字段的文档时
- 需要填写日期时
- 避免使用假设或硬编码的时间

**核心要点**：
- **禁止任何具体日期**：如 `2025-01-21`、`2025-12-01` 等
- **禁止格式占位符**：如 `YYYY-MM-DD`、`[日期]` 等
- **禁止模糊表述**：如"今天"、"当前日期"、"现在"等
- **必须运行命令获取**：使用 `date '+%Y-%m-%d'` 获取当前日期

---

## 交互规范

交互规范定义了 AI 助手与用户交互的规则。

### 31. 开放性问题确认规范 (`open-question-confirmation.md`)

**描述**：针对开放性问题，必须通过询问方式与用户的理解达成一致，只有达成一致后才能给出方案。

**应用场景**：
- 用户需求描述不完整或存在歧义
- 存在多种可能的实现方式
- 涉及多个技术选型方案
- 业务规则存在多种解释

**核心要点**：
- **必须达成一致**：只有与用户的理解达成一致后，才能给出方案
- **持续确认**：如果未达成一致，必须持续与用户进行确认，直到达成一致
- **禁止假设**：不能假设用户的理解，必须通过询问确认
- **禁止跳过**：不能跳过确认环节，直接给出方案
- 识别开放性问题 → 明确询问用户 → 等待用户回复 → 根据回复给出方案

---

## 项目规范

项目规范定义了项目级别的规范和原则。

### 32. 项目清洁原则 (`project-clean-principle.md`)

**描述**：避免将 AI 辅助开发工具和非业务相关的脚本混入项目核心代码，保持项目结构的纯净性。

**应用场景**：
- 创建 AI 辅助工具时选择存放位置
- 工具生成的产物（如图片、文档）的存放位置
- 避免污染项目核心代码库

**核心要点**：
- **工具存放位置**：将 AI 辅助开发工具放在 `.cursor-rules` 目录下
- **产物存放位置**：将工具生成的产物统一放在 `.cursor-rules/assets/` 目录下
- **禁止行为**：
  - 将 AI 辅助工具放入项目核心目录（如 `scripts/`）
  - 将工具生成产物放入项目核心目录（如 `assets/`、`docs/`）
  - 混淆工具职责

---

## 研发阶段提示词

研发阶段提示词按研发流程的不同阶段组织，目前包含以下内容：

### 文档阶段（documentation/）

#### 33. 文档生成规范（整合版）(`document-generation.md`) ⭐⭐⭐ 推荐优先使用

**描述**：统一的文档生成规范，整合了所有文档类型的规范，包括技术方案、架构图、WIKI 等文档类型。

**应用场景**：
- 生成任何类型的技术文档时
- 需要统一的文档生成规范时
- 新项目开始文档工作时

**核心要点**：
- ✅ **技术方案文档规范**：引用 `templates/technical-solution-template.md` 模板
- ✅ **架构图文档规范**：图表模块化、说明可折叠（详细参考 `architecture-diagram-template.md`）
- ✅ **WIKI 文档规范**：总分总结构、易于导航（详细参考 `wiki-output.md`）
- ✅ **通用规范**：时间格式、内容格式、代码格式等

**如何提问**：
- 明确要求生成文档或遵循文档规范
- 示例："生成技术方案文档，遵循文档生成规范"
- 示例："创建架构图文档，使用统一的文档规范"
- 示例："输出 WIKI 文档，遵循文档生成规范"

**推荐使用**：建议优先使用此文件，它包含了所有文档类型的规范。

---

#### 34. 架构图文档模板规范 (`architecture-diagram-template.md`) ⭐⭐ 快速参考

**描述**：架构图文档模板规范，专门针对架构图文档的详细规范。

**应用场景**：
- 需要快速查看架构图文档的详细规范时
- 需要详细的图表组织要求和示例时

**核心要点**：
- 文档结构必须清晰，包含目录导航
- 图表模块化，每个模块独立展示
- 说明可折叠，使用 `<details>` 标签
- 便于导航，使用锚点链接

**使用建议**：
- ⚠️ **主规范**：`document-generation.md` 已包含架构图文档规范的核心内容
- ✅ **快速参考**：如果需要快速查看详细规范，可以查看此文件

---

#### 35. WIKI 输出规范 (`wiki-output.md`) ⭐⭐ 快速参考

**描述**：WIKI 输出规范，专门针对 WIKI 文档的详细规范。

**应用场景**：
- 需要快速查看 WIKI 文档的详细规范时
- 需要详细的 WIKI 文档格式要求和工具说明时

**核心要点**：
- 遵循总分总结构（开头概述、主体详细内容、结尾总结）
- 标题层级不超过 4 级
- 长文档必须包含目录
- 使用清晰的格式和样式

**使用建议**：
- ⚠️ **主规范**：`document-generation.md` 已包含 WIKI 文档规范的核心内容
- ✅ **快速参考**：如果需要快速查看详细规范，可以查看此文件

---

### 其他阶段

- **需求分析阶段**（requirements/）：待添加
- **设计阶段**（design/）：待添加
- **开发阶段**（development/）：待添加
- **测试阶段**（testing/）：待添加

---

## 项目类型提示词

项目类型提示词按项目类型组织，目前包含以下目录（内容待添加）：

- **前端项目**（frontend/）：前端项目特定类型的提示词模板
- **后端项目**（backend/）：后端项目特定类型的提示词模板
- **全栈项目**（fullstack/）：全栈项目特定类型的提示词模板
- **移动端项目**（mobile/）：移动端项目特定类型的提示词模板

---

## 模板文件

模板文件提供可复用的通用提示词模板：

### 35. 项目规则模板 (`project-template.md`)

**描述**：用于创建新项目类型规则的模板，包含规则概述、规则内容、使用说明、注意事项等结构。

**应用场景**：
- 创建新的项目类型规则时
- 需要统一的规则模板格式时

---

### 36. 阶段规则模板 (`stage-template.md`)

**描述**：用于创建新阶段规则的模板，包含规则概述、规则内容、使用说明、注意事项等结构。

**应用场景**：
- 创建新的阶段规则时
- 需要统一的规则模板格式时

---

### 37. 规则模块化指南 (`rule-modularization-guide.md`)

**描述**：规则模块化的指导文档，说明如何将规则拆分为模块。

**应用场景**：
- 需要将大型规则文件拆分为模块时
- 了解规则模块化的最佳实践时

---

## 统计信息

### 文件统计

- **总文件数**：60 个 Markdown 文件（已整合优化）
- **通用阶段提示词**：44 个文件
  - 模式规则：13 个文件（已删除 Debug 模式相关文件，整合重复文件）
  - 代码规范：13 个文件
  - 文档规范：2 个文件
  - 交互规范：1 个文件
  - 项目规范：1 个文件
- **研发阶段提示词**：3 个文件（documentation 阶段）
- **项目类型提示词**：4 个 README 文件（内容待添加）
- **模板文件**：3 个文件

---

## 使用说明

### 提示词合并机制

所有提示词文件通过合并脚本自动合并到 `.cursorrules` 文件中：

1. **索引文件**（`index.md`）：不会被合并，仅用于导航和说明
2. **规则文件**：按字母顺序合并，索引文件优先合并
3. **合并脚本**：`scripts/core/merge_prompts.sh`

### 文件命名规范

- 使用 **kebab-case** 命名（如 `new-rule.md`）
- 索引文件统一命名为 `index.md`
- 规则文件使用描述性名称

### 文件结构规范

每个规则文件应包含：

1. **文件头注释**：文件说明和创建时间
2. **规则内容**：具体的规则定义
3. **使用说明**：如何使用该规则
4. **注意事项**：需要注意的事项

---

## 相关文档

- [项目 README](../README.md)
- [提示词目录 README](prompts/README.md)
- [快速开始指南](../QUICK_START.md) - 快速开始使用
- [AI 生成说明](../AI_GENERATED.md)

---

## 更新日志

- **2025-12-15**：
  - 创建初始概述文档，包含所有提示词的描述和应用场景
  - 为部分提示词规则添加"如何提问"部分，指导用户如何提问才能有效命中相应的提示词规则
- **2025-12-16**：
  - 重组模式规则分类方式：从按 Plan/Act/Debug 模式分类改为按功能/使用场景分类
  - 新的分类方式：方案输出和计划、代码执行和文件操作、调试和问题定位、模式切换和响应格式、工具调用和安全检查
  - 使文档更直观，用户更易找到相关规则
- **2025-12-19**：
  - 优化和整合提示词规则：
    - ✅ 整合文件写入规则：将 `long-text-check.md` 整合到 `file-write.md`，文件大小检查作为写入前的第一步
    - ✅ 优化时间相关规则：在 `time-check.md` 中引用 `time-format.md`，减少重复内容
    - ✅ 明确文档阶段规范主次关系：`document-generation.md` 作为整合版推荐优先使用，其他文件作为快速参考
  - 规则架构顶层重构：
    - ✅ 创建 `tool-permission-system.md`：工具权限系统顶层规则文件，整合所有检查机制
      - 整合工具调用检查机制（从 `tool-check.md`）
      - 整合禁止行为清单（从 `forbidden-behaviors.md`）
      - 成为工具调用检查的唯一入口
    - ✅ 删除重复文件：`tool-check.md`、`forbidden-behaviors.md`、`solution-completeness.md`（已整合）
    - ✅ 移除 Debug 模式：删除 `debug-mode.md` 及相关文件
    - ✅ 完善意图识别机制：
      - 整合为检查流程第零步（在工具分类判断之前）
      - 检查流程从 3 步扩展为 4 步
      - 添加强制确认机制：意图识别失败时，必须与用户确认（不能跳过）
      - 定义标准确认格式（提供明确选项，至少 3 个选项）
      - 明确确认后的处理流程（重新识别 → 从第零步重新开始）
      - 添加重新识别次数限制（最多 2 次，避免无限循环）
      - 优化询问机制和确认机制：统一格式，明确关系
  - 更新相关索引文件和概述文档

---

*本文档由 AI 自动生成，如有问题请及时反馈*
