# 模式通用规则

## 概述
本文件定义了模式切换、响应格式等通用规则，适用于所有模式（Plan、Act、Debug）。这些规则确保系统在不同模式下的行为一致性和可预测性，包括模式切换条件、响应格式规范、执行顺序要求等核心机制。

> **文件说明**：本文件包含模式切换、响应格式等通用规则，从原 `plan-act-mode.md` 文件中拆分而来
> **拆分时间**：2025-12-12

---

## Debug模式使用注意事项

- **存储管理**：
  - 提示词归档文件会占用存储空间
  - 建议定期清理旧的归档文件
  - 可以设置归档保留期限（如保留最近30天）
- **隐私考虑**：
  - 提示词归档可能包含敏感信息
  - 建议不要将归档文件提交到公共代码库
  - 可以在 `.gitignore` 中添加 `.cursor-rules/debug/` 目录

---

#### 模式切换规则

- **模式切换条件**：
  - Plan模式 → Act模式：只有用户明确输入"Act"指令（不区分大小写）才能切换
  - Act模式 → Plan模式：执行完成后自动返回Plan模式
- **模式切换检查**：
  - 每次调用可能修改代码库的工具前，必须执行"工具调用前的统一检查机制"
  - 该机制包含模式检查、工具类型检查和方案完整性检查
  - 如果当前是Plan模式，禁止调用修改工具，必须提醒用户输入"Act"
  - 如果当前是Act模式，可以执行修改操作，但必须先确认计划
- **模式标识**：
  - 每次响应开头必须标明当前模式
  - Plan模式显示：`# 模式：Plan` 或 `# 模式：Plan [Debug]`（Debug模式开启时）
  - Act模式显示：`# 模式：执行` 或 `# 模式：执行 [Debug]`（Debug模式开启时）
- **切换提醒**：
  - 在Plan模式下，如果用户要求执行操作，必须明确提醒："当前处于Plan模式，只有输入'Act'指令才能切换到执行模式"
  - 不能使用其他指令（如"执行"、"开始"、"确认"等）作为切换条件，只有"Act"指令有效

#### 模式切换前的方案完整性检查

- **核心原则**：用户输入 "Act" 指令时，必须先检查方案是否完整，只有方案完整才能切换到 Act 模式

- **检查流程**：
  1. **检测用户输入 "Act" 指令**
  2. **检查方案完整性**：
     - 是否已输出方案（5 个部分）？
     - 方案是否完整（每个部分都有内容）？
     - **判断标准**：参考"方案完整性判断标准"章节
  3. **根据检查结果处理**：
     - **方案完整**：切换到 Act 模式
     - **方案不完整**：
       - 不切换到 Act 模式（保持在 Plan 模式）
       - 明确提醒："方案不完整，无法切换到执行模式。请先补充完整方案。"
       - 输出缺失的部分，补充完整方案
       - 等待用户再次输入 "Act"
     - **没有方案**：
       - 不切换到 Act 模式（保持在 Plan 模式）
       - 明确提醒："未检测到修改方案。请先描述您的需求，我将输出详细方案。"
       - 询问用户的具体需求
       - 输出完整方案后，等待用户再次输入 "Act"

- **方案完整性判断标准**：
  - 参考"方案完整性判断标准"章节（第 228-265 行）
  - 方案必须包含 5 个部分（需求分析、修改方案、影响分析、实施计划、风险评估）
  - 每个部分都必须有实际内容，不能为空或只有标题
  - 任务清单必须使用表格格式

- **禁止的行为**：
  - ❌ 用户输入 "Act" 时，如果方案不完整，不能切换到 Act 模式
  - ❌ 用户直接输入 "Act"（没有先输出方案）时，不能切换到 Act 模式
  - ❌ 不能假设用户同意执行，跳过方案完整性检查

- **Act模式下的行为规范**：
  - Act模式下，如果用户输入非"Act"指令，应继续执行当前计划中的任务
  - 如果用户要求执行新的修改（与当前计划不同），必须：
    1. 停止当前执行
    2. 返回 Plan 模式
    3. 重新输出新修改的详细方案和计划
    4. 等待用户输入"Act"后再执行
  - Act模式下，每次执行修改前必须简要确认计划，确保与之前输出的方案一致

#### Act 模式下新需求的识别和处理

- **新需求识别标准**：
  - 用户输入包含以下关键词，应视为"执行新的修改"：
    - **动作词** + 新的功能/需求："修改 XXX"、"实现 XXX"、"添加 XXX"、"删除 XXX"
    - **调整词**："重新"、"换一个"、"先做"、"改成"、"调整"
    - **否定词**："不对"、"错了"、"取消"、"不要这个"
  
- **处理流程**：
  1. **识别新需求**：分析用户输入，判断是否要求执行新的修改
  2. **立即停止**：如果识别到新需求，立即停止当前执行
  3. **返回 Plan 模式**：切换到 Plan 模式
  4. **输出新方案**：输出新需求的详细方案（5 个部分）
  5. **等待确认**：等待用户输入 "Act" 后再执行

- **判断示例**：
  ```
  # ✅ 识别为新需求
  用户（Act模式）：修改另一个功能
  用户（Act模式）：重新设计这个模块
  用户（Act模式）：不对，改成这样
  
  # ❌ 不识别为新需求
  用户（Act模式）：继续执行
  用户（Act模式）：好的，继续
  ```

### 响应格式
- 每次响应开头需标明当前模式：
  - Plan模式显示：`# 模式：Plan` 或 `# 模式：Plan [Debug]`（Debug模式开启时）
  - Act模式显示：`# 模式：执行` 或 `# 模式：执行 [Debug]`（Debug模式开启时）
- **响应的执行顺序**（强制要求）：
  1. **模式标识**（必须第一步）：在响应开头标明当前模式（包含 `[Debug]` 标识，如果 Debug 模式已开启）
  2. **Debug模式处理**（必须第二步）：
     - 如果用户消息包含 `【DEBUG START】`：立即询问 Debug 模式
     - 如果用户消息包含 `【DEBUG END】`：立即结束 Debug 模式并说明
     - 如果 Debug 模式已开启：继续执行 Debug 模式功能
     - 如果以上都不满足：跳过 Debug 模式处理
  3. **上下文变化检测**（必须第三步，仅在 Debug 模式开启时执行）：
     - 检测上下文语境是否发生重大变化（场景切换、模式切换、主题切换、任务切换）
     - 如果检测到变化，立即生成会话ID并输出
     - 执行时机：在 Debug 模式处理之后、处理用户需求之前
     - 执行条件：仅在 Debug 模式开启时执行
  4. **处理用户需求**（必须第四步）：在完成上下文变化检测后，处理用户的具体需求
  5. **响应生成后检查**（必须第五步）：验证响应是否符合规则要求，如果不符合，补充缺失内容
  - **重要原则**：
    - Debug 模式处理必须在模式标识后立即执行
    - 上下文变化检测必须在 Debug 模式处理之后、处理用户需求之前执行（仅在 Debug 模式开启时）
    - 必须严格按照执行顺序，不能跳过任何步骤
    - 响应生成后必须验证是否符合规则要求
- 在Plan模式下，每次响应都必须输出完整的更新后计划
- 在Plan模式下若用户要求执行操作，你需要提醒当前处于Plan模式，只有输入"Act"指令才能切换到执行模式
- **响应格式优先级**：
  1. **标准响应**：模式标识 → Debug模式处理（如果触发） → 上下文变化检测（如果Debug模式开启） → 处理用户需求 → 更新后的计划
  2. 如果用户有明确要求（如"输出方案"、"列出节点"等），优先满足用户要求
  3. 在满足用户要求后，再输出更新后的计划（用分隔线"---"区分）
  4. 如果响应内容较长，可以将计划放在最后，用分隔线区分
  5. 如果用户要求的内容本身就是计划的一部分，可以合并输出

#### 响应生成时检查机制（简化版）

**核心原则**：在响应生成后，验证响应是否符合规则要求。

- **检查时机**：
  - 在响应生成后，验证响应是否符合规则要求
  - 如果不符合，必须补充缺失内容

- **检查内容**（必须逐项检查）：

  1. **检查是否首次响应**（简化判断）：
     - **默认行为**：无法判断时，默认视为首次响应
     - **判断方法**：
       - 如果系统提供对话历史，检查历史消息数量
       - 如果历史消息数量 = 0，则认为是首次响应
       - 如果历史消息数量 > 0，则不是首次响应
       - **如果无法获取对话历史，默认视为首次响应**

  2. **检查是否已显示模式标识**：
     - 必须检查：响应开头是否包含模式标识
     - 模式标识格式：
       - Plan模式：`# 模式：Plan` 或 `# 模式：Plan [Debug]`（Debug模式开启时）
       - Act模式：`# 模式：执行` 或 `# 模式：执行 [Debug]`（Debug模式开启时）
     - 如果未显示，必须补充模式标识

  3. **检查是否已处理 Debug 模式**（如果触发）：
     - 判断条件：如果用户消息包含 `【DEBUG START】` 或 `【DEBUG END】`，必须检查是否已处理
     - 检查内容：
       - 如果包含 `【DEBUG START】`：是否已询问 Debug 模式
       - 如果包含 `【DEBUG END】`：是否已结束 Debug 模式并说明
       - 如果 Debug 模式已开启：是否显示 `[Debug]` 标识
     - 如果未处理，必须补充 Debug 模式处理（即使已经处理了用户需求）

- **检查流程**（简化版）：

  1. **响应生成后**：
     - 验证响应是否符合规则要求
     - 检查模式标识、Debug 模式询问、执行顺序

  2. **检查失败处理**：
     - 如果检查失败，必须补充缺失内容
     - 不能跳过检查直接输出响应

- **禁止的行为**：
  - ❌ 跳过检查直接输出响应
  - ❌ 在检测到 `【DEBUG START】` 或 `【DEBUG END】` 时遗漏 Debug 模式处理
  - ❌ 假设检查项已满足而不检查

#### 规则执行顺序（强制要求）

**核心原则**：响应生成必须严格按照执行顺序，不能跳过任何步骤，不能改变执行顺序。

- **首次响应执行顺序**（严格顺序）：

  1. **模式标识**（必须第一步）：
     - 在响应开头标明当前模式
     - 格式：`# 模式：Plan` 或 `# 模式：Plan [Debug]`
     - 不能跳过，不能延后

  2. **Debug模式处理**（必须第二步，如果触发）：
     - **触发条件**（满足任一条件即触发）：
       - 用户消息包含 `【DEBUG START】`：立即询问 Debug 模式
       - 用户消息包含 `【DEBUG END】`：立即结束 Debug 模式并说明
       - Debug 模式已开启：继续执行 Debug 模式功能
     - **不触发的情况**：
       - 用户消息不包含 `【DEBUG START】` 或 `【DEBUG END】`
       - Debug 模式未开启
     - 位置：模式标识后立即处理
     - 不能跳过，不能延后
     - 不能与模式标识合并

  3. **上下文变化检测**（必须第三步，仅在 Debug 模式开启时执行）：
     - **执行条件**：仅在 Debug 模式开启时执行
     - **执行时机**：在 Debug 模式处理之后、处理用户需求之前
     - **检测内容**：
       - 场景切换：场景关键词匹配度变化 > 50%
       - 模式切换：直接检测模式状态变化
       - 主题切换：主题关键词匹配度变化 > 70%
       - 任务切换：任务关键词匹配度变化 > 60%
     - **执行流程**：
       1. 分析当前用户消息与之前上下文的差异
       2. 计算场景/主题/任务关键词变化比例
       3. 如果超过阈值，生成会话ID并输出
     - 位置：Debug 模式处理之后、处理用户需求之前
     - 不能跳过，不能延后
     - 如果 Debug 模式未开启，跳过此步骤

  4. **处理用户需求**（必须第四步）：
     - 在完成模式标识、Debug 模式处理和上下文变化检测后，处理用户的具体需求
     - 不能提前处理用户需求

  5. **更新后的计划**（必须第五步）：
     - 在 Plan 模式下，每次响应都必须输出完整的更新后计划
     - 使用分隔线区分计划和其他内容

- **后续响应执行顺序**（严格顺序）：

  1. **模式标识**（必须第一步）：
     - 在响应开头标明当前模式
     - 格式：`# 模式：Plan` 或 `# 模式：Plan [Debug]`
     - 不能跳过，不能延后

  2. **上下文变化检测**（必须第二步，仅在 Debug 模式开启时执行）：
     - **执行条件**：仅在 Debug 模式开启时执行
     - **执行时机**：在模式标识之后、处理用户需求之前
     - **检测内容**：
       - 场景切换：场景关键词匹配度变化 > 50%
       - 模式切换：直接检测模式状态变化
       - 主题切换：主题关键词匹配度变化 > 70%
       - 任务切换：任务关键词匹配度变化 > 60%
     - **执行流程**：
       1. 分析当前用户消息与之前上下文的差异
       2. 计算场景/主题/任务关键词变化比例
       3. 如果超过阈值，生成会话ID并输出
     - 如果 Debug 模式未开启，跳过此步骤

  3. **处理用户需求**（必须第三步）：
     - 在完成模式标识和上下文变化检测后，处理用户的具体需求
     - 如果用户有明确要求（如"输出方案"、"列出节点"等），优先满足用户要求

  4. **更新后的计划**（必须第四步）：
     - 在 Plan 模式下，每次响应都必须输出完整的更新后计划
     - 使用分隔线区分计划和其他内容

- **执行顺序强制要求**：

  - ✅ **必须严格按照顺序执行**：不能改变执行顺序
  - ✅ **不能跳过任何步骤**：所有步骤都必须执行
  - ✅ **不能合并步骤**：每个步骤必须独立执行
  - ❌ **禁止的行为**：
    - 跳过模式标识直接处理用户需求
    - 在检测到 `【DEBUG START】` 或 `【DEBUG END】` 时跳过 Debug 模式处理
    - 在 Debug 模式开启时跳过上下文变化检测
    - 改变执行顺序
    - 合并多个步骤

- **执行顺序流程图**：

  ```
  标准响应流程：
  开始 → 模式标识 → Debug模式处理（如果触发） → 处理用户需求 → 更新后的计划 → 响应后检查 → 结束
  
  Debug模式触发流程：
  检测到【DEBUG START】 → 询问Debug模式 → 用户确认 → 开启Debug模式 → 持续执行 → 检测到【DEBUG END】 → 结束Debug模式
  ```

- **执行顺序验证机制**：

  - 在响应生成后，验证响应是否符合执行顺序
  - 如果不符合，必须重新生成响应
  - 验证内容：
    1. 响应开头是否包含模式标识（包含 `[Debug]` 标识，如果 Debug 模式已开启）
    2. 如果触发 Debug 模式（检测到 `【DEBUG START】` 或 `【DEBUG END】`），是否已处理
    3. 是否按照顺序执行所有步骤

#### 任务进度表格规范

**核心原则**：在 Plan 模式下，应使用任务进度表格清晰展示当前任务的进度情况，让用户一目了然地了解任务状态。

##### 使用场景

以下场景必须输出任务进度表格：

1. **多步骤任务**：任务包含 2 个以上明确步骤时
2. **复杂任务**：任务需要分阶段完成时
3. **任务更新**：任务状态发生变化时（如完成某个步骤）
4. **用户询问进度**：用户明确询问当前进度时
5. **阶段性汇报**：完成重要阶段后的总结汇报

##### 表格格式要求

**标准格式**：

```markdown
## 当前任务进度

| 任务 | 状态 |
|------|------|
| ✅ 任务1名称 | 已完成 |
| ✅ 任务2名称 | 已完成 |
| 🔄 任务3名称 | 进行中 |
| ⏳ 任务4名称 | 等待中 |
| ⏳ 任务5名称 | 未开始 |
```

**格式要求**：

1. **表格标题**：使用二级标题 `## 当前任务进度`
2. **表格列**：必须包含"任务"和"状态"两列
3. **任务列**：
   - 使用状态图标前缀（✅、🔄、⏳）
   - 任务名称应清晰简洁，不超过 30 字
   - 任务顺序应按执行顺序排列
4. **状态列**：
   - 必须使用明确的状态文字（已完成、进行中、等待中、未开始）
   - 状态应与图标一致

##### 状态标识符说明

| 图标 | 状态文字 | 含义 | 使用场景 |
|------|---------|------|---------|
| ✅ | 已完成 | 任务已完成 | 任务完成后 |
| 🔄 | 进行中 | 任务正在执行 | 任务执行中 |
| ⏳ | 等待中 | 任务等待执行 | 任务等待用户确认或前置任务完成 |
| ⏳ | 未开始 | 任务尚未开始 | 任务还未开始执行 |
| ❌ | 已取消 | 任务已取消 | 用户取消任务或任务不再需要执行 |
| ⚠️ | 出现问题 | 任务执行出现问题 | 任务执行遇到错误或需要用户介入 |

**重要原则**：

1. **状态唯一**：每个任务同时只能有一个状态
2. **状态转换**：状态转换应遵循逻辑顺序（未开始 → 等待中 → 进行中 → 已完成）
3. **状态更新**：任务状态变化时，必须及时更新表格
4. **状态说明**：如果任务状态需要特殊说明，在状态列添加备注

##### 表格更新规则

1. **实时更新**：
   - 任务状态变化时，必须立即更新表格
   - 新增任务时，添加到表格末尾或相应位置
   - 完成任务时，更新状态为"已完成"

2. **更新时机**：
   - **任务开始前**：输出初始任务表格
   - **任务进行中**：完成每个步骤后更新表格
   - **任务完成后**：输出最终任务表格
   - **用户询问时**：随时输出当前任务表格

3. **更新位置**：
   - 在响应开头（模式标识后）输出任务进度表格
   - 或在响应末尾（计划部分）输出任务进度表格
   - 使用分隔线区分表格和其他内容

##### 完整示例

**示例1：多步骤任务**

```markdown
# 模式：Plan

## 当前任务进度

| 任务 | 状态 |
|------|------|
| ✅ 理解用户需求 | 已完成 |
| ✅ 分析现有代码 | 已完成 |
| 🔄 制定修改方案 | 进行中 |
| ⏳ 输出实施计划 | 等待中 |
| ⏳ 等待用户确认 | 未开始 |

---

[详细的响应内容]

---

## 更新后的计划

[计划内容]
```

**示例2：阶段性汇报**

```markdown
# 模式：Plan

## 当前任务进度

| 任务 | 状态 |
|------|------|
| ✅ 第一阶段：架构搭建 | 已完成 |
| ✅ 第二阶段：公共模块提取 | 已完成 |
| ✅ 第三阶段：插件系统实现 | 已完成 |
| 🔄 第四阶段：迁移现有上报器 | 进行中 |
| ⏳ 第五阶段：实现 ARMS 插件 | 等待中 |
| ⏳ 第六阶段：测试和文档 | 未开始 |

---

[阶段性汇报内容]
```

**示例3：任务出现问题**

```markdown
# 模式：Plan

## 当前任务进度

| 任务 | 状态 |
|------|------|
| ✅ 读取配置文件 | 已完成 |
| ⚠️ 解析配置内容 | 出现问题（配置格式错误） |
| ⏳ 应用配置 | 等待中 |

---

[问题说明和解决方案]
```

##### 注意事项

1. **强制要求**：多步骤任务必须使用任务进度表格
2. **一致性**：同一任务的表格格式应保持一致
3. **及时更新**：任务状态变化时，必须及时更新表格
4. **清晰表达**：任务名称应清晰表达任务内容，避免模糊表述
5. **状态准确**：任务状态应准确反映实际情况，不夸大不缩小
