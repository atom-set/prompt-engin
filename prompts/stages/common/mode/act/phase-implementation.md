# Phase Implementation

> **文件说明**：本文件包含 phase implementation 相关规则
> **规则来源**：rules/stages/common/mode/act/phase-implementation.md

---

#### 大型工程分阶段实施规则

**核心原则**：大型工程必须分阶段实施，每个阶段完成后确认和测试再继续

- **适用场景**（满足任一条件即必须分阶段）：
  - **阶段数量超过 2 个**（主要触发条件）⚠️
  - 任务数量超过 **5 个**
  - 需要创建/修改 **5 个以上**文件
  - 单个文件超过 **500 行**
  - 预计总代码量超过 **1000 行**
  - 涉及多个模块或功能的实施

- **快速判断标准**：
  - **阶段数量 ≤ 2**：可以不分阶段，或简化确认流程
  - **阶段数量 > 2**：必须严格遵循分阶段实施规则
  - 特殊情况：即使只有 2 个阶段，但如果单个阶段包含 >5 个任务或 >500 行代码，也建议分阶段

- **阶段 vs 子任务的区别**：
  - **阶段**：独立的、可测试的功能单元（如：修复可选链、消除重复、拆分文件）
  - **子任务**：阶段内部的细分任务（如：阶段2包含3个子任务）
  - **规则适用**：只对"阶段"级别应用分阶段实施规则，不对"子任务"级别应用
  - **测试询问时机**：只在"阶段"完成后询问，不在"子任务"完成后询问
  - **判断标准**：
    - 如果任务可以独立测试和验证，视为"阶段"
    - 如果任务只是阶段内部的实现步骤，视为"子任务"

- **阶段划分策略**：

  1. **阶段划分原则**：
     
     a) **按任务数量划分**（推荐）：
        - 每个阶段包含 **2-4 个任务**
        - 任务之间依赖关系清晰
        - 优先完成基础任务，再完成依赖任务
     
     b) **按功能模块划分**：
        - 每个阶段聚焦一个功能模块
        - 模块内任务一次性完成
        - 适合模块间独立性强的场景
     
     c) **按依赖关系划分**：
        - 第一阶段：基础设施（类型定义、接口定义）
        - 第二阶段：核心功能（主要业务逻辑）
        - 第三阶段：辅助功能（工具类、配置）
        - 第四阶段：测试和文档
     
     d) **按复杂度划分**：
        - 先实现简单任务（<200 行，1-2 个文件）
        - 再实现中等任务（200-500 行，2-3 个文件）
        - 最后实现复杂任务（>500 行，多文件）
  
  2. **阶段大小控制**：
     - **推荐阶段大小**：每个阶段 2-4 个任务
     - **最小阶段**：至少 1 个任务（独立完整的任务）
     - **最大阶段**：不超过 5 个任务（避免阶段过大）
     - **代码量参考**：每个阶段 200-500 行代码（可根据任务调整）
     - **文件数量参考**：每个阶段 1-3 个文件
  
  3. **阶段实施流程**：
     
     - **第1步：输出当前阶段计划**
       - 阶段编号和名称
       - 包含的任务清单（任务编号、名称、预计代码量）
       - 阶段预计耗时
       - 依赖关系说明
     
     - **第2步：实施当前阶段所有任务**
       - 按任务顺序逐个实施
       - 每个任务完成后，输出完成提示
       - 遵循"文件写入规则"（框架优先、分步填充）
     
     - **第3步：阶段验证**
       - 检查所有任务是否完成
       - 验证代码语法和格式
       - 输出阶段摘要（已创建/修改的文件清单）
       - **阶段完成标准**：
         - ✅ 所有任务已完成
         - ✅ 代码语法和格式验证通过
         - ✅ 已输出阶段摘要
         - ✅ 满足以上条件后，才进入"询问测试"环节
     
     - **第4步：询问是否需要测试**⚠️
       - 明确询问："是否需要对当前阶段进行测试？"
       - 提供选项：
         - **需要测试**：暂停实施，等待用户测试完成后再继续
         - **不需要测试**：跳过测试，直接进入下一步
         - **稍后测试**：标记待测试，继续下一阶段
       - 测试建议：
         - 基础架构阶段：建议测试（验证类型定义、接口正确性）
         - 核心功能阶段：强烈建议测试（验证功能正确性）
         - 辅助功能阶段：可选测试
         - 最后阶段：必须测试
     
     - **第5步：询问用户是否继续下一阶段**
       - 输出阶段摘要（已完成任务数、下一阶段任务预览）
       - 明确询问："✅ 阶段 X 已完成（共 N 个任务），是否继续下一阶段？"
       - 提供选项：继续/暂停/调整
     
     - **第6步：等待用户确认**
       - 用户回复"继续"或"Act"：继续下一阶段
       - 用户回复"暂停"：返回 Plan 模式，保留当前进度
       - 用户回复"调整"：返回 Plan 模式，允许调整后续阶段计划
       - **用户说"继续X阶段"的处理**：
         - 如果用户说"继续第二阶段"或"继续下一阶段"：
           - ⚠️ **必须先询问测试**："是否需要对当前阶段进行测试？"
           - 等待用户明确回复后，再继续
         - 如果用户说"不需要测试，继续第二阶段"：
           - ✅ 可以跳过测试询问，直接继续
         - 如果用户说"已测试，继续第二阶段"：
           - ✅ 可以跳过测试询问，直接继续
         - 如果用户说"稍后测试，继续第二阶段"：
           - ✅ 标记待测试，跳过测试询问，直接继续
         - **重要原则**：除非用户明确表示"不需要测试"或"已测试"，否则必须询问测试
  
  4. **阶段确认机制**：
     - 每个阶段完成后，必须先询问测试，再询问是否继续
     - 提供详细的阶段摘要（已完成 + 待完成）
     - 等待用户明确回复后才能继续
     - 如果用户暂停，必须返回 Plan 模式
     - **测试询问的时机**：
       - 只在"阶段"完成后询问，不在"子任务"完成后询问
       - 如果阶段包含多个子任务，等所有子任务完成后再询问测试
       - 每个阶段完成后，必须执行完整的测试询问流程（第4步）
     - **用户回复的处理**：
       - 如果用户说"继续X阶段"但未明确测试状态，必须先询问测试
       - 如果用户明确表示"不需要测试"或"已测试"，可以跳过测试询问
       - 必须等待用户明确回复后才能继续

- **测试确认流程示意**：

  ```
  阶段 N 实施完成
      ↓
  代码验证（语法、格式）
      ↓
  询问："是否需要对当前阶段进行测试？"
      ↓
  ├─ 需要测试 → 暂停，等待用户测试完成
  │               ↓
  │           用户测试完成，回复"继续"
  │               ↓
  ├─ 不需要测试 → 跳过测试
  │               ↓
  └─ 稍后测试 → 标记待测试
                  ↓
  询问："是否继续下一阶段？"
      ↓
  ├─ 继续 → 进入下一阶段
  ├─ 暂停 → 返回 Plan 模式
  └─ 调整 → 返回 Plan 模式，调整计划
  ```

- **测试建议和最佳实践**：
  
  1. **基础架构阶段**（类型定义、接口定义）：
     - 建议测试：验证类型定义正确性、接口完整性
     - 测试方式：编译检查、简单示例代码
  
  2. **核心功能阶段**（主要业务逻辑）：
     - 强烈建议测试：验证核心功能正确性
     - 测试方式：单元测试、集成测试、功能验证
     - 重点：数据流、状态管理、错误处理
  
  3. **辅助功能阶段**（工具类、配置）：
     - 可选测试：根据功能复杂度决定
     - 测试方式：功能验证、配置检查
  
  4. **最后阶段**（测试和文档）：
     - 必须测试：完整的功能验证和回归测试
     - 测试方式：完整测试套件、端到端测试
  
  5. **测试时机建议**：
     - 关键阶段后必须测试（如核心功能完成后）
     - 其他阶段可以延后测试（积累到某个节点统一测试）
     - 最后阶段必须完整测试

- **阶段划分示例**：

  **示例1：基于任务数量的阶段划分**
  
  假设有 12 个任务，可以划分为 4 个阶段：
  
  ```
  阶段1：基础架构（任务 1-3，共 3 个任务）
    - 任务1：创建插件类型定义（plugin.types.ts，~100行）
    - 任务2：创建插件基类（BasePlugin.ts，~80行）
    - 任务3：创建插件管理器（PluginManager.ts，~150行）
    → 测试建议：建议测试（验证类型定义和接口）
  
  阶段2：核心插件实现（任务 4-7，共 4 个任务）
    - 任务4：实现压缩插件（CompressionPlugin.ts，~120行）
    - 任务5：实现存储插件（StoragePlugin.ts，~150行）
    - 任务6：实现加密插件（EncryptionPlugin.ts，~100行）
    - 任务7：实现重试插件（RetryPlugin.ts，~130行）
    → 测试建议：强烈建议测试（验证核心功能）
  
  阶段3：核心模块改造（任务 8-10，共 3 个任务）
    - 任务8：改造 BatchReporter（BatchReporter.new.ts，~300行）
    - 任务9：更新配置模块（config.ts，~80行）
    - 任务10：更新导出接口（index.ts，~50行）
    → 测试建议：强烈建议测试（验证集成正确性）
  
  阶段4：测试和文档（任务 11-12，共 2 个任务）
    - 任务11：编写单元测试（*.test.ts，~200行）
    - 任务12：更新文档和示例（README.md，~150行）
    → 测试建议：必须测试（完整回归测试）
  ```
  
  **示例2：基于功能模块的阶段划分**
  
  ```
  阶段1：类型系统（2 个任务，~200行）
    - 插件类型定义
    - 接口定义
  
  阶段2：插件实现（4 个任务，~500行）
    - 4 个核心插件独立实现
  
  阶段3：集成改造（3 个任务，~400行）
    - BatchReporter 改造
    - 配置更新
    - 导出更新
  
  阶段4：完善和测试（3 个任务，~350行）
    - 测试编写
    - 文档更新
    - 示例代码
  ```

- **重要原则**：
  - ✅ 每个阶段独立完整，可单独验证和测试
  - ✅ 阶段间依赖关系清晰
  - ✅ 用户可随时暂停和调整
  - ✅ 阶段大小适中（2-4 个任务）
  - ✅ 关键阶段后必须询问是否测试
  - ✅ 阶段数量 > 2 时必须执行此规则
  - ✅ 必须区分"阶段"和"子任务"，只对阶段应用规则
  - ✅ 用户说"继续X阶段"时，除非明确表示测试状态，否则必须先询问测试
  - ❌ 禁止跨阶段混合实施
  - ❌ 禁止未确认就继续下一阶段
  - ❌ 禁止跳过测试确认环节（除非用户明确表示不需要测试或已测试）
  - ❌ 禁止阶段过大（>5 个任务）
  - ❌ 禁止假设用户意图，必须等待明确回复

- **执行检查清单**（开始分阶段实施前）：
  - [ ] 已评估工程规模（阶段数、任务数、文件数、代码量）
  - [ ] 已判断是否需要分阶段实施（阶段数 > 2？）
  - [ ] 已制定阶段划分方案（明确每个阶段包含的任务）
  - [ ] 已区分"阶段"和"子任务"（只对阶段应用规则）
  - [ ] 已准备阶段清单和依赖关系
  - [ ] 已确认每个阶段大小合适（2-4 个任务）
  - [ ] 已规划测试节点（哪些阶段需要测试）

- **阶段完成后的检查清单**（每个阶段完成后必须执行）：
  - [ ] 已检查所有任务是否完成
  - [ ] 已验证代码语法和格式
  - [ ] 已输出阶段摘要
  - [ ] **已询问是否需要测试**（必须执行，除非用户明确表示不需要测试或已测试）
  - [ ] **已询问是否继续下一阶段**（必须执行）
  - [ ] **已等待用户明确回复**（必须等待，不能假设用户意图）

---