# 工具权限系统

> **文件说明**：本文件定义工具分类体系和统一检查流程，是工具调用权限的核心规则和唯一入口
> **创建时间**：2025-12-19（本地时间）
> **重构时间**：2025-12-19（整合所有检查机制，简化架构）
> **更新时间**：2025-12-19（完善意图识别机制，整合到检查流程第零步，添加强制确认机制，优化确认后流程和重新识别限制）

---

## 概述

本文件定义了工具权限系统的核心规则，包括工具分类体系（只读工具和修改工具）、统一检查流程（4步检查：意图识别、工具分类、权限检查、方案完整性检查）、意图识别机制、方案输出要求等。这是工具调用权限的核心规则和唯一入口，所有工具调用前都必须执行统一的检查流程。

---

## 一、工具分类体系

### 核心原则

所有工具按操作类型分为两类：**只读工具**和**修改工具**。分类决定权限检查方式。

### 只读工具（Read-Only Tools）

**定义**：不会改变代码库状态的工具。

**工具列表**：
- `read_file`：读取文件内容
- `list_dir`：查看目录结构
- `glob_file_search`：搜索文件
- `codebase_search`：语义搜索代码库
- `grep`：文本搜索代码库
- `read_lints`：查看 Linter 错误（仅查看，不自动修复）
- `todo_write`：创建和管理 TODO 列表（仅用于记录计划，不代表执行许可）
- `run_terminal_cmd`：**仅查询类命令**（详见下方命令分类）

**权限**：所有模式（Plan、Act）都允许调用。

### 修改工具（Modification Tools）

**定义**：可能改变代码库状态的工具。

**工具列表**：
- `search_replace`：修改现有文件
- `write`：创建新文件或修改现有文件
- `delete_file`：删除文件
- `edit_notebook`：编辑笔记本
- `run_terminal_cmd`：**文件系统修改类、包管理器类等命令**（详见下方命令分类）

**权限**：
- **Plan 模式**：禁止调用
- **Act 模式**：需要方案完整 + 用户确认（输入 "Act" 指令）

### run_terminal_cmd 命令分类

#### 查询类命令（只读工具）

**允许的命令类型**：
- **Git 查询类**：`git status`、`git log`、`git diff`、`git show`、`git branch`（仅查看）、`git tag`（仅查看）等
- **文件系统查询类**：`ls`、`cat`、`head`、`tail`、`grep`、`find`、`which`、`type`、`pwd`、`whoami`、`date`、`echo`（仅输出）、`wc`、`stat`、`file` 等
- **检查类**：`test`、`[`、`[[`、`command -v`、`which`、`type` 等
- **信息类**：`uname`、`hostname`、`env`、`printenv`、`ps`、`top`、`df`、`du`（仅查询）等
- **其他只读操作**：任何不会修改文件系统、Git 仓库、包管理器状态、环境配置的命令

#### 修改类命令（修改工具）

**禁止的命令类型**：
- **Git 修改类**：`git add`、`git commit`、`git push`、`git pull`、`git merge`、`git rebase`、`git reset`、`git checkout`（切换分支）、`git branch`（创建/删除分支）、`git tag`（创建/删除标签）等
- **文件系统修改类**：`mkdir`、`rmdir`、`rm`、`mv`、`cp`（复制到项目外）、`touch`、`chmod`、`chown`、`ln`、`unlink` 等
- **包管理器类**：`npm install`、`npm uninstall`、`npm update`、`yarn add`、`yarn remove`、`pip install`、`pip uninstall`、`composer install`、`composer update` 等
- **构建和部署类**：`npm run build`（如果会修改文件）、`make`（如果会修改文件）、`docker build`、`docker push` 等
- **环境配置类**：`export`（持久化）、`setenv`、修改 `.bashrc`、`.zshrc` 等配置文件

**判断原则**：
- 如果命令可能修改文件系统、Git 仓库、包管理器状态或环境配置，则视为修改工具
- 如果不确定命令是否会改变代码库状态，应禁止并询问用户
- 查询类命令必须确保是只读操作，不会产生副作用

---

## 二、统一检查流程

### 核心原则

所有工具调用前必须执行统一的检查流程，不能跳过任何步骤。**本文件是工具调用检查的唯一入口**。

### 检查流程（4步）

#### 第零步：意图识别检查（仅修改工具）

**检查条件**：仅在调用修改工具前执行此检查。只读工具可跳过此步骤。

**检查内容**：
1. 分析用户输入，判断是否有修改需求
2. 如果判断不确定，先询问用户意图
3. 如果意图识别失败，触发安全机制

**意图识别判断标准**：
- **关键词匹配**：检查是否包含修改需求关键词（创建、修改、添加、删除、实现、修复、更新、替换、编写、生成等）
- **上下文分析**：分析上下文语境，判断是修改需求还是询问
- **判断结果**：
  - ✅ **明确修改需求**：用户明确要求修改代码 → 进入第一步（工具分类判断）
  - ✅ **明确询问**：用户明确只是询问（如"如何"、"为什么"等） → 跳过后续检查，直接提供解答
  - ⚠️ **不确定**：无法明确判断 → 询问用户意图，等待明确回复
  - ❌ **识别失败**：意图识别失败或用户反馈误判 → 触发安全机制

**询问机制**（当判断不确定时）：
- **询问时机**：在响应生成时，如果意图识别不确定
- **询问方式**：
  - 直接询问用户意图
  - 提供明确选项（是/否、修改/不修改、需要/不需要等）
  - 使用清晰、明确的问题表述
- **询问格式**（推荐格式，可使用简化版本）：
  ```
  ## 🤔 需要确认您的意图
  
  根据您的描述，我无法明确判断您的需求。
  
  **请确认您的需求**：
  - **选项A**：我需要修改代码 → 请明确说明要修改什么
  - **选项B**：我只是想了解/询问 → 我将为您提供解答
  - **选项C**：取消当前操作 → 我将停止当前流程
  
  请选择您的选项（A/B/C），或直接说明您的具体需求。
  ```
  - **格式说明**：
    - 可以使用上述标准格式（与确认机制保持一致）
    - 也可以使用简化格式（直接询问，提供明确选项）
    - 确认机制必须使用标准格式（详见下方"安全机制处理流程"）
- **判断用户回复**：
  - 如果用户回复包含明确关键词（是/否、需要/不需要、修改/不修改等） → 根据回复判断
  - 如果用户回复仍不明确 → 触发安全机制

**误判检测机制**（基于用户反馈）：
- **检测时机**：用户明确反馈时
- **检测方式**：
  - 用户明确表示"我只是想了解"、"不需要修改"、"我只是询问"等
  - 用户明确拒绝方案输出（如"不需要"、"取消"等）
  - 用户明确表示"我误判了"、"我理解错了"等
- **处理**：立即触发安全机制

**安全机制触发条件**（满足任一条件即触发）：
- ❌ **意图识别不确定且无法澄清**：
  - 判断标准：询问用户意图后，用户回复仍不明确（无法判断是/否、需要/不需要）
  - 处理：触发安全机制
- ❌ **用户明确反馈误判**：
  - 判断标准：用户明确表示"我只是想了解"、"不需要修改"等
  - 处理：立即触发安全机制
- ❌ **意图识别机制异常**（保留，但需明确异常定义）：
  - 判断标准：意图识别机制本身出现异常或无法执行
  - 处理：触发安全机制

**安全机制处理流程**：

1. **立即切换到 Plan 模式**：
   - 如果当前是 Act 模式，立即切换回 Plan 模式
   - 如果当前是 Plan 模式，保持在 Plan 模式

2. **禁止调用修改工具**：
   - 禁止调用所有修改工具（即使方案已输出）
   - 方案作废（不再使用）

3. **只允许调用只读工具**：
   - 只允许调用只读工具（read_file、codebase_search、grep 等）
   - 用于理解用户需求或提供解答

4. **强制与用户确认**（必须执行，不能跳过）：
   - **确认时机**：检测到意图识别失败时，立即与用户确认
   - **确认方式**：使用明确的确认格式，提供明确的选项
   - **确认内容**：
     - 说明意图识别失败的原因
     - 提示当前处于 Plan 模式（只读模式）
     - 说明安全机制已触发（统一使用 Plan 模式）
     - 询问用户具体需求，提供明确选项
   - **确认格式**（标准格式）：
     ```
     ## ⚠️ 意图识别失败，需要确认
     
     由于意图识别失败，为确保安全，当前处于 Plan 模式（只读模式）。
     
     **失败原因**：[说明具体原因]
     - 意图识别不确定，无法判断您的需求
     - 检测到误判，您明确表示只是询问
     - 意图识别机制异常
     
     **请确认您的需求**：
     - **选项A**：我需要修改代码 → 请明确说明要修改什么
     - **选项B**：我只是想了解/询问 → 我将为您提供解答
     - **选项C**：取消当前操作 → 我将停止当前流程
     
     请选择您的选项（A/B/C），或直接说明您的具体需求。
     ```
   - **确认要求**：
     - 必须使用上述标准格式或类似格式
     - 必须提供明确的选项（至少 3 个选项）
     - 必须说明失败原因和当前模式
     - 必须等待用户明确回复

5. **等待用户明确回复**（强制要求）：
   - **必须等待**：必须等待用户明确回复，不能假设用户意图
   - **不能跳过**：不能跳过确认步骤，直接执行任何操作
   - **回复判断**：
     - 如果用户选择选项A（需要修改） → 根据用户说明重新进行意图识别，输出方案
     - 如果用户选择选项B（只是询问） → 提供解答，不执行修改操作
     - 如果用户选择选项C（取消） → 停止当前流程
     - 如果用户直接说明需求 → 根据说明重新进行意图识别
   - **重新识别后的处理流程**：
     - **重新识别成功（明确修改需求）**：
       - 从第零步重新开始执行完整检查流程（重新进行意图识别检查）
       - 如果意图识别明确为修改需求 → 进入第一步（工具分类判断）
       - 后续按正常流程执行（输出方案 → 等待用户输入 "Act" → 执行修改）
     - **重新识别成功（明确询问）**：
       - 跳过后续检查，直接提供解答
       - 不执行任何修改操作
     - **重新识别仍失败**：
       - 再次触发安全机制（最多重新识别 2 次，避免无限循环）
       - 如果已达到最大重新识别次数（2 次），提示用户："意图识别多次失败，请直接明确说明您的需求"
   - **重新识别次数限制**：
     - 最多重新识别 2 次（包括首次识别）
     - 如果重新识别次数超过限制，停止重新识别，提示用户直接说明需求

**检查结果**：
- 如果明确为修改需求 → 进入第一步（工具分类判断）
- 如果明确为询问 → 跳过后续检查，直接提供解答
- 如果触发安全机制 → 统一使用 Plan 模式，禁止调用修改工具，**必须与用户确认**
  - **确认后的处理流程**（详见"等待用户明确回复"章节）：
    - 根据用户回复重新进行意图识别
    - 重新识别成功（明确修改需求） → 从第零步重新开始执行完整检查流程
    - 重新识别成功（明确询问） → 跳过后续检查，直接提供解答
    - 重新识别仍失败 → 再次触发安全机制（最多重新识别 2 次）

#### 第一步：工具分类判断

**检查内容**：
1. 判断工具类型：只读工具 or 修改工具
2. 如果是 `run_terminal_cmd`，**必须检查命令内容**：
   - 解析命令字符串，判断命令类型
   - 查询类命令 → 只读工具
   - 修改类命令 → 修改工具

**命令内容检查机制**（强制要求）：
- **必须检查**：调用 `run_terminal_cmd` 前，必须解析命令内容
- **检查方法**：
  - 检查命令是否包含禁止的关键词（如 `mkdir`、`rm`、`git add` 等）
  - 检查命令是否属于禁止的命令类型
- **检查结果**：
  - 如果命令属于修改类 → 视为修改工具
  - 如果命令属于查询类 → 视为只读工具
  - 如果不确定 → 禁止执行，询问用户

**检查结果**：
- 如果是只读工具 → 进入第二步（权限检查）
- 如果是修改工具 → 进入第二步（权限检查）

#### 第二步：权限检查

**检查内容**：
1. 确认当前主模式（Plan 或 Act）
2. 根据工具类型和模式判断权限

**模式确认规则**（强制要求，简化版）：
- ⚠️ **无Act指令时统一按Plan模式**：任何情况下，如果用户没有输入"Act"指令，都必须保持在Plan模式（最高优先级规则）
- ⚠️ **唯一切换条件**：只有用户明确输入"Act"指令（不区分大小写）且方案完整才能切换到Act模式
- ⚠️ **默认模式**：系统默认以Plan模式开始
- ⚠️ **禁止复杂判断**：不能进行任何复杂的判断，只需检查是否有"Act"指令，没有则统一按Plan模式处理

**权限判断**：
- **只读工具**：
  - Plan 模式 → ✅ 允许调用
  - Act 模式 → ✅ 允许调用
- **修改工具**：
  - Plan 模式 → ❌ 禁止调用，立即停止并提醒用户需要切换到 Act 模式
  - Act 模式 → 进入第三步（方案完整性检查）

**检查结果**：
- 如果允许调用 → 执行工具调用
- 如果禁止调用 → 停止执行，提醒用户

#### 第三步：方案完整性检查（仅修改工具 + Act 模式）

**检查条件**：仅在修改工具 + Act 模式下执行此检查。

**检查内容**：
1. 检查是否已输出完整方案（包含需求分析、修改方案、影响分析、实施计划、风险评估 5 个部分）
2. 检查是否已输出任务清单（使用表格格式）
3. 检查用户是否已输入 "Act" 指令

**方案完整性判断标准**：
- **需求分析**（至少包含）：问题描述或用户需求、要解决的核心问题、需求背景（可选）
- **修改方案**（至少包含）：修改的文件列表、修改的位置、具体的修改内容
- **影响分析**（至少包含）：对现有功能的影响、对相关文件的影响、是否需要向下兼容（可选）
- **实施计划**（至少包含）：任务清单（表格格式）、实施顺序、注意事项（可选）
- **风险评估**（至少包含）：潜在问题（至少 1 个）、回滚方案（至少说明如何回滚）

**检查结果**：
- 如果方案完整且用户已输入 "Act" → ✅ 允许调用
- 如果方案不完整 → ❌ 禁止调用，停止执行并返回 Plan 模式补充方案
- 如果用户未输入 "Act" → ❌ 禁止调用，提醒用户输入 "Act" 指令

---

## 三、意图识别和方案输出机制

### 核心原则

在调用修改工具前，必须识别用户意图并输出完整方案。意图识别在检查流程的第零步执行。

**重要说明**：
- **执行时机**：意图识别在检查流程的第零步执行（详见"统一检查流程"章节）
- **安全机制**：当意图识别失败或不确定时，统一使用 Plan 模式（只读模式），确保安全
- **强制确认**：意图识别失败时，必须与用户确认，不能跳过确认步骤
- **方案输出**：只有在意图识别明确为修改需求时，才输出完整方案

### 意图识别机制

**判断标准**：
- **关键词匹配**：检查是否包含修改需求关键词（创建、修改、添加、删除、实现、修复、更新、替换、编写、生成等）
- **上下文分析**：分析上下文语境，判断是修改需求还是询问
- **不确定时询问**：如果判断不确定，先询问用户意图

**触发方案输出的条件**（满足任一条件即必须输出方案）：
- ✅ 用户明确要求修改代码
- ✅ 用户描述问题但可能涉及代码修改（如"XXX 不工作"、"XXX 无法跳转"、"需要修复 XXX"）
- ✅ 用户描述功能需求但需要代码实现
- ✅ 任何可能调用文件修改工具的情况

**判断流程**：
```
用户输入 → 关键词匹配 → 上下文分析 → 判断类型 → 执行对应流程
如果判断不确定 → 询问用户意图 → 等待明确回复 → 执行对应流程
如果识别失败 → 触发安全机制 → 统一使用 Plan 模式 → 强制与用户确认 → 等待用户回复 → 根据回复重新识别
```

**示例场景**：
- "创建文件" → 修改需求 → 输出方案
- "如何创建文件" → 询问 → 提供解答
- "需要创建文件" → 修改需求 → 输出方案
- "生成一个通用的提示词" → 不确定 → 询问："您希望我生成一个通用的提示词模板吗？还是只是想了解如何生成？"

**重要原则**：
- ✅ **安全优先**：意图识别失败时，优先确保安全，统一使用 Plan 模式
- ✅ **强制确认**：意图识别失败时，必须与用户确认，不能跳过确认步骤
- ✅ **明确提示**：必须明确说明意图识别失败的原因和当前模式
- ✅ **等待回复**：必须等待用户明确回复，不能假设用户意图
- ❌ **禁止假设**：不能假设用户意图，必须等待明确回复
- ❌ **禁止跳过**：不能跳过安全机制和确认步骤，直接执行修改操作

### 方案输出要求

**必须包含的 5 个部分**：
1. **需求分析**：问题描述或用户需求、要解决的核心问题、需求背景（可选）
2. **修改方案**：修改的文件列表、修改的位置、具体的修改内容
3. **影响分析**：对现有功能的影响、对相关文件的影响、是否需要向下兼容（可选）
4. **实施计划**：任务清单（表格格式）、实施顺序、注意事项（可选）
5. **风险评估**：潜在问题（至少 1 个）、回滚方案（至少说明如何回滚）

**输出时机要求**：
- 方案输出必须在调用修改工具前的**同一响应中**完成
- 禁止跨响应直接调用修改工具（未等待用户输入 "Act"）

---

## 四、禁止的行为

### Plan 模式禁止的行为

1. ❌ **创建TODO后立即执行代码修改**
   - 即使创建了TODO列表，也不能立即执行代码修改
   - 必须等待用户输入"Act"指令后才能执行

2. ❌ **假设用户同意执行（即使创建了TODO）**
   - 不能假设用户同意执行，必须明确等待用户输入"Act"

3. ❌ **跳过"Act"指令直接执行修改**
   - 只有用户明确输入"Act"指令才能切换到执行模式

4. ❌ **在Plan模式下调用文件修改工具**
   - 禁止调用 search_replace、write、delete_file、edit_notebook 等文件修改工具
   - 禁止运行可能改变代码库的命令

5. ❌ **将问题描述误判为纯询问，直接执行修改**
   - 必须先确认用户意图，再决定是否输出方案

6. ❌ **假设用户描述问题就是要求修改，跳过方案输出**
   - 必须先输出方案，等待用户确认后才能执行

7. ❌ **在未明确用户意图时，直接执行代码修改**
   - 如果用户意图不明确，必须先询问确认

8. ❌ **未输出方案就调用工具（即使工具本身是允许的）**
   - 如果用户有修改需求，必须先输出方案，才能调用任何工具
   - 即使工具本身是允许的（如 read_file），如果涉及修改需求，也必须先输出方案
   - 禁止在未输出方案的情况下，直接调用工具执行修改操作

9. ❌ **跨响应调用修改工具（未等待"Act"指令）**
   - 如果先调用了只读工具，必须在同一响应中输出完整方案，不能跨响应直接调用修改工具
   - 如果输出了方案，必须等待用户明确输入"Act"后才能调用工具，不能在下一个响应中直接调用工具

10. ❌ **跳过检查步骤直接调用工具**
    - 禁止在未显式输出检查结果的情况下调用工具
    - 禁止假设检查已执行，必须显式输出检查结果

11. ❌ **意图识别失败时继续执行修改操作**
    - 当意图识别失败或不确定时，必须统一使用 Plan 模式
    - 禁止在意图识别失败时调用修改工具

12. ❌ **意图识别失败时跳过用户确认**
    - 当意图识别失败时，必须与用户确认
    - 禁止跳过确认步骤，直接执行任何操作
    - 禁止假设用户意图，必须等待用户明确回复

### Act 模式禁止的行为

1. ❌ **在Act模式下但方案不完整时执行修改**
   - 如果方案不完整，必须停止执行并返回 Plan 模式补充方案

2. ❌ **跳过方案输出直接调用文件修改工具**
   - 必须先输出完整方案，才能执行修改

3. ❌ **继续执行，忽略发现的问题**
   - 如果执行过程中发现方案有问题，必须立即停止

4. ❌ **不说明问题，直接修正**
   - 必须明确说明发现的问题和修正方案

5. ❌ **不返回 Plan 模式，在 Act 模式下直接修正方案**
   - 如果方案有问题，必须返回 Plan 模式输出修正方案

6. ❌ **意图识别失败时继续执行修改操作**
   - 当意图识别失败或不确定时，必须统一使用 Plan 模式
   - 禁止在意图识别失败时继续执行修改操作

### 通用禁止行为

1. ❌ **收到修改需求后直接执行代码修改**
   - 必须先输出方案，等待用户确认

2. ❌ **收到问题描述（可能涉及代码修改）后直接执行代码修改**
   - 必须先确认用户意图，再决定是否输出方案

3. ❌ **只输出简单计划就执行修改**
   - 必须输出完整的5部分方案（需求分析、修改方案、影响分析、实施计划、风险评估）

4. ❌ **假设用户同意执行（即使输出了方案）**
   - 必须等待用户明确输入"Act"指令

5. ❌ **跳过方案输出直接执行修改**
   - 必须先输出方案，才能执行修改

6. ❌ **假设用户意图，直接执行修改**
   - 如果用户意图不明确，必须先询问确认

7. ❌ **跳过确认，直接输出方案**
   - 如果用户意图不明确，必须先确认再输出方案

8. ❌ **使用模糊表述询问用户**
   - 必须使用清晰、明确的问题表述

9. ❌ **在用户未明确回复时，继续执行修改**
   - 必须等待用户明确回复后再继续

10. ❌ **跨响应调用修改工具（未等待"Act"指令）**
    - 如果输出了方案，必须等待用户明确输入"Act"后才能调用工具，不能在下一个响应中直接调用工具

11. ❌ **跳过检查步骤直接调用工具**
    - 禁止在未显式输出检查结果的情况下调用工具
    - 禁止假设检查已执行，必须显式输出检查结果

12. ❌ **调用 `run_terminal_cmd` 时未检查命令内容**
    - 必须解析命令内容，判断命令类型
    - 禁止假设命令类型而不检查

---

## 五、检查清单

调用工具前必须逐项检查：

- [ ] **第零步：意图识别检查**（仅修改工具）
  - [ ] 如果是修改工具，已执行意图识别（判断用户是否有修改需求）
  - [ ] 如果判断不确定，已询问用户意图
  - [ ] 如果意图识别失败或用户反馈误判，已触发安全机制（统一使用 Plan 模式）
  - [ ] **如果触发安全机制，已强制与用户确认**（必须执行，不能跳过）：
    - [ ] 已使用标准确认格式，提供明确选项（至少 3 个选项）
    - [ ] 已说明失败原因和当前模式
    - [ ] 已等待用户明确回复
  - [ ] 已确认意图识别结果（明确修改需求/明确询问/触发安全机制）

- [ ] **第一步：工具分类判断**
  - [ ] 已判断工具类型（只读工具 or 修改工具）
  - [ ] 如果是 `run_terminal_cmd`，已检查命令内容
  - [ ] 已确认工具分类结果

- [ ] **第二步：权限检查**
  - [ ] 已确认当前主模式（Plan 或 Act）
  - [ ] 已根据工具类型和模式判断权限
  - [ ] 已确认是否允许调用

- [ ] **第三步：方案完整性检查**（仅修改工具 + Act 模式）
  - [ ] 已检查是否已输出完整方案（5 个部分）
  - [ ] 已检查用户是否已输入 "Act" 指令
  - [ ] 已确认满足所有检查条件

---

## 六、错误处理

- **误调用禁止的工具**：
  - 立即停止执行
  - 提醒用户需要切换到 Act 模式
  - 说明当前模式和工具类型

- **方案不完整**：
  - 停止执行
  - 返回 Plan 模式
  - 输出缺失的部分，补充完整方案

- **命令内容检查失败**：
  - 如果无法判断命令类型，禁止执行
  - 询问用户命令的具体用途
  - 根据用户回复决定是否允许执行

- **意图识别失败**：
  - 立即切换到 Plan 模式（如果当前是 Act 模式）
  - 统一使用 Plan 模式（只读模式）
  - 禁止调用修改工具（即使方案已输出）
  - 方案作废（不再使用）
  - **强制与用户确认**（必须执行，不能跳过）：
    - 使用标准确认格式，提供明确选项（至少 3 个选项）
    - 说明失败原因和当前模式
    - 必须等待用户明确回复
  - **确认后的处理流程**：
    - 根据用户回复重新进行意图识别
    - 重新识别成功（明确修改需求） → 从第零步重新开始执行完整检查流程
    - 重新识别成功（明确询问） → 跳过后续检查，直接提供解答
    - 重新识别仍失败 → 再次触发安全机制（最多重新识别 2 次，避免无限循环）

---

## 七、重要原则

1. **意图识别优先**：调用修改工具前，先识别用户意图
2. **工具分类优先**：先分类工具，再检查权限
3. **命令内容检查强制**：`run_terminal_cmd` 必须检查命令内容
4. **方案输出前置**：修改工具调用前必须输出完整方案
5. **检查流程**：统一为 4 步检查流程（第零步：意图识别检查，第一步：工具分类判断，第二步：权限检查，第三步：方案完整性检查）
6. **唯一入口**：本文件是工具调用检查的唯一入口，所有检查机制都在此定义
7. **安全优先**：意图识别失败时，统一使用 Plan 模式，确保安全
8. **强制确认**：意图识别失败时，必须与用户确认，不能跳过确认步骤

---

## 八、适用场景

**以下场景必须遵循此规范**：

- ✅ **所有工具调用**：调用任何工具前都必须执行检查
- ✅ **所有代码修改**：所有代码修改都需要方案完整且用户确认
- ✅ **所有模式切换**：模式切换必须满足相应条件
- ✅ **所有需要确认的操作**：需要确认的操作必须等待用户明确回复
- ✅ **意图识别失败**：意图识别失败时，统一使用 Plan 模式，必须与用户确认

---

## 九、相关文件

- `solution-output.md`：方案输出内容的详细要求（5个部分的具体格式）
- `security-permissions.md`：安全权限规则的快速参考（权限矩阵）
- `mode-common.md`：模式切换和响应格式规范
