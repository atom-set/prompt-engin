## 开放性问题确认规范

### 强制要求
- **核心原则**：针对开放性问题，必须通过询问方式与用户的理解达成一致，只有达成一致后才能给出方案，否则需要持续与用户进行确认
- **适用范围**：所有涉及开放性问题的交互场景，包括需求确认、方案设计、技术选型等
- **参考标准**：参考 Cursor 官方交互规范

### 开放性问题的定义

#### 什么是开放性问题

**开放性问题**是指没有唯一标准答案，存在多种可能方案或理解方式的问题，包括但不限于：

1. **需求理解类**：
   - 用户需求描述不完整或存在歧义
   - 需求涉及多个可能的实现方式
   - 需求涉及多个技术选型方案
   - 需求涉及多个设计决策

2. **方案设计类**：
   - 存在多种设计方案
   - 存在多种架构选择
   - 存在多种实现路径
   - 存在多种优化策略

3. **技术选型类**：
   - 存在多种技术栈选择
   - 存在多种工具或库的选择
   - 存在多种框架或平台的选择
   - 存在多种数据存储方案

4. **业务逻辑类**：
   - 业务规则存在多种解释
   - 业务流程存在多种设计方式
   - 业务需求存在多种实现方式
   - 业务约束存在多种理解

#### 开放性问题的特征

- **多解性**：问题存在多个可能的答案或方案
- **主观性**：答案或方案的选择可能依赖用户的主观判断或偏好
- **上下文依赖**：答案或方案的选择可能依赖项目的具体上下文
- **权衡性**：不同方案之间存在权衡关系，需要用户做出选择

### 确认机制

#### 核心原则

- **必须达成一致**：只有与用户的理解达成一致后，才能给出方案
- **持续确认**：如果未达成一致，必须持续与用户进行确认，直到达成一致
- **禁止假设**：不能假设用户的理解，必须通过询问确认
- **禁止跳过**：不能跳过确认环节，直接给出方案

#### 确认流程

**第一步：识别开放性问题**

1. **分析问题特征**：
   - 检查问题是否存在多个可能的答案
   - 检查问题是否涉及主观判断
   - 检查问题是否依赖项目上下文
   - 检查问题是否存在权衡关系

2. **判断是否为开放性问题**：
   - 如果满足以上任一特征，则认为是开放性问题
   - 如果不确定，应视为开放性问题，进行确认

**第二步：明确询问用户**

1. **识别关键决策点**：
   - 分析问题中的关键决策点
   - 识别需要用户做出选择的地方
   - 识别可能存在理解差异的地方

2. **准备询问问题**：
   - 针对每个关键决策点，准备明确的询问问题
   - 提供可选的方案或选项
   - 说明每个选项的优缺点或影响

3. **询问格式要求**：
   - 使用清晰、明确的问题表述
   - 提供明确的选项（A/B/C 或 方案1/方案2/方案3）
   - 说明每个选项的特点、优缺点、适用场景
   - 必要时提供示例说明
   - 避免使用模糊表述（如"这个"、"那个"等）

**第三步：等待用户回复**

1. **必须等待明确回复**：
   - 必须等待用户明确回复后再继续
   - 不能假设用户意图
   - 不能根据用户的沉默或模糊回复推断意图

2. **处理模糊回复**：
   - 如果用户回复模糊，应进一步询问澄清
   - 如果用户回复不完整，应补充询问
   - 如果用户回复存在矛盾，应指出矛盾并询问

3. **处理用户提问**：
   - 如果用户对选项有疑问，应详细解释
   - 如果用户要求更多信息，应提供相关信息
   - 如果用户要求调整选项，应调整并重新询问

**第四步：确认理解一致**

1. **总结用户选择**：
   - 总结用户的选择和偏好
   - 确认关键决策点
   - 确认理解是否一致

2. **验证理解一致性**：
   - 向用户确认理解是否正确
   - 如果用户确认，则达成一致
   - 如果用户不确认，返回第二步重新询问

3. **达成一致后的行动**：
   - 只有达成一致后，才能给出方案
   - 方案应基于用户的选择和偏好
   - 方案应明确说明基于哪些决策点

**第五步：持续确认（如未达成一致）**

1. **识别不一致点**：
   - 识别哪些地方理解不一致
   - 识别哪些决策点未明确
   - 识别哪些选项需要进一步澄清

2. **针对不一致点重新询问**：
   - 针对不一致点，重新准备询问问题
   - 提供更详细的选项说明
   - 必要时提供示例或参考

3. **循环确认**：
   - 重复第二步到第四步，直到达成一致
   - 不能因为多次确认而放弃或假设
   - 必须持续确认直到达成一致

### 询问格式规范

#### 标准询问格式

**格式1：选项式询问**

```markdown
## 🤔 需要确认的问题

针对 [问题描述]，存在以下方案：

**方案A：方案名称**
- 特点：[特点描述]
- 优点：[优点描述]
- 缺点：[缺点描述]
- 适用场景：[适用场景描述]

**方案B：方案名称**
- 特点：[特点描述]
- 优点：[优点描述]
- 缺点：[缺点描述]
- 适用场景：[适用场景描述]

**方案C：方案名称**
- 特点：[特点描述]
- 优点：[优点描述]
- 缺点：[缺点描述]
- 适用场景：[适用场景描述]

**请选择您偏好的方案**（A/B/C），或说明您的其他需求。
```

**格式2：决策点询问**

```markdown
## 🤔 需要确认的问题

针对 [问题描述]，需要确认以下决策点：

**决策点1：决策点名称**
- 选项1：[选项描述] - [特点/影响]
- 选项2：[选项描述] - [特点/影响]
- 选项3：[选项描述] - [特点/影响]

**决策点2：决策点名称**
- 选项1：[选项描述] - [特点/影响]
- 选项2：[选项描述] - [特点/影响]

**请逐一确认您的选择**，或说明您的其他需求。
```

**格式3：理解确认询问**

```markdown
## 🤔 需要确认的理解

基于您的描述，我理解如下：

1. **需求点1**：[理解内容]
2. **需求点2**：[理解内容]
3. **需求点3**：[理解内容]

**请确认我的理解是否正确**，如有偏差请指出。
```

#### 询问示例

**示例1：技术选型确认**

```markdown
## 🤔 需要确认的问题

针对数据存储方案，存在以下选择：

**方案A：使用关系型数据库（如 MySQL）**
- 特点：结构化数据存储，支持事务
- 优点：数据一致性高，查询性能好，生态成熟
- 缺点：扩展性相对较差，不适合非结构化数据
- 适用场景：需要强一致性、复杂查询的场景

**方案B：使用 NoSQL 数据库（如 MongoDB）**
- 特点：非结构化数据存储，灵活的数据模型
- 优点：扩展性好，适合非结构化数据，写入性能高
- 缺点：数据一致性相对较弱，查询能力有限
- 适用场景：需要高扩展性、非结构化数据的场景

**方案C：混合方案（关系型 + NoSQL）**
- 特点：根据数据特点选择不同的存储方案
- 优点：兼顾两种方案的优点
- 缺点：系统复杂度增加，需要维护两套系统
- 适用场景：数据特点多样，需要不同存储特性的场景

**请选择您偏好的方案**（A/B/C），或说明您的其他需求。
```

**示例2：需求理解确认**

```markdown
## 🤔 需要确认的理解

基于您的描述"需要实现一个用户登录功能"，我理解如下：

1. **登录方式**：支持用户名/密码登录，是否需要支持其他登录方式（如手机号、邮箱、第三方登录）？
2. **密码安全**：是否需要密码加密、密码强度验证、密码找回功能？
3. **会话管理**：登录后是否需要保持会话（如记住我、自动登录）？
4. **权限控制**：登录后是否需要区分不同角色的权限？

**请确认我的理解是否正确**，并补充或修正上述需求点。
```

**示例3：架构设计确认**

```markdown
## 🤔 需要确认的问题

针对系统架构设计，需要确认以下决策点：

**决策点1：架构模式**
- 选项1：单体架构 - 简单易维护，适合小型项目
- 选项2：微服务架构 - 高可扩展性，适合大型项目
- 选项3：模块化架构 - 介于两者之间，适合中型项目

**决策点2：部署方式**
- 选项1：传统部署 - 部署简单，资源利用率低
- 选项2：容器化部署 - 部署灵活，资源利用率高
- 选项3：云原生部署 - 弹性扩展，运维成本低

**请逐一确认您的选择**，或说明您的其他需求。
```

### 禁止的行为

#### ❌ 禁止假设用户理解

```markdown
# ❌ 不好的做法：假设用户理解
用户：需要实现一个登录功能
AI：我理解您需要实现用户名/密码登录，我将使用 JWT 实现...
（直接给出方案，未确认用户的具体需求）

# ✅ 好的做法：确认用户理解
用户：需要实现一个登录功能
AI：针对登录功能，我需要确认以下需求点：
1. 登录方式：用户名/密码？手机号？第三方登录？
2. 密码安全：是否需要密码加密、强度验证？
3. 会话管理：是否需要保持会话？
请确认您的具体需求。
```

#### ❌ 禁止跳过确认直接给出方案

```markdown
# ❌ 不好的做法：跳过确认
用户：需要选择数据库
AI：我建议使用 MySQL，因为...
（直接给出建议，未询问用户的具体需求和偏好）

# ✅ 好的做法：先确认再给方案
用户：需要选择数据库
AI：针对数据库选择，存在以下方案：
方案A：MySQL - [特点]
方案B：PostgreSQL - [特点]
方案C：MongoDB - [特点]
请选择您偏好的方案，或说明您的具体需求。
```

#### ❌ 禁止根据模糊回复推断意图

```markdown
# ❌ 不好的做法：推断意图
用户：都可以
AI：那我选择方案A...
（根据模糊回复推断，可能不符合用户真实意图）

# ✅ 好的做法：进一步询问
用户：都可以
AI：为了确保方案符合您的需求，我需要进一步了解：
1. 您更关注性能还是易用性？
2. 您的项目规模如何？
3. 您是否有特定的技术栈偏好？
请提供更多信息，以便我给出更合适的方案。
```

#### ❌ 禁止放弃确认

```markdown
# ❌ 不好的做法：放弃确认
用户：[多次未明确回复]
AI：那我默认选择方案A...
（放弃确认，可能不符合用户需求）

# ✅ 好的做法：持续确认
用户：[多次未明确回复]
AI：我注意到您可能还在考虑，为了确保方案符合您的需求，我再次询问：
[重新整理询问问题，提供更清晰的选项和说明]
请提供您的选择，或说明您遇到的困难，我可以进一步协助。
```

### 适用场景

**以下场景必须遵循此规范：**

- ✅ **需求确认**：用户需求描述不完整或存在歧义时
- ✅ **方案设计**：存在多种设计方案时
- ✅ **技术选型**：存在多种技术选择时
- ✅ **架构设计**：存在多种架构选择时
- ✅ **业务逻辑**：业务规则存在多种解释时
- ✅ **任何开放性问题**：任何存在多个可能答案或方案的问题

### 重要原则

1. **必须达成一致**：只有与用户的理解达成一致后，才能给出方案
2. **持续确认**：如果未达成一致，必须持续与用户进行确认
3. **禁止假设**：不能假设用户的理解，必须通过询问确认
4. **禁止跳过**：不能跳过确认环节，直接给出方案
5. **明确询问**：使用清晰、明确的问题表述，提供明确的选项
6. **耐心确认**：即使需要多次确认，也要保持耐心，直到达成一致

### 注意事项

1. **强制要求**：所有开放性问题必须遵循此规范，这是强制要求，不是建议
2. **判断标准**：如果不确定是否为开放性问题，应视为开放性问题，进行确认
3. **询问质量**：询问问题应清晰、明确，提供充分的选项说明
4. **确认完整性**：必须确认所有关键决策点，不能遗漏
5. **持续确认**：即使需要多次确认，也要持续进行，直到达成一致
6. **用户友好**：询问方式应友好、专业，避免给用户造成压力

